(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('vue-demi')) :
  typeof define === 'function' && define.amd ? define(['exports', 'vue-demi'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global['VueUseShared utilities'] = {}, global.VueDemi));
}(this, (function (exports, vueDemi) { 'use strict';

  /**
   * Two-way refs synchronization.
   *
   * @param a
   * @param b
   */
  function biSyncRef(a, b) {
      const flush = 'sync';
      const stop1 = vueDemi.watch(a, (newValue) => {
          b.value = newValue;
      }, {
          flush,
          immediate: true,
      });
      const stop2 = vueDemi.watch(b, (newValue) => {
          a.value = newValue;
      }, {
          flush,
          immediate: true,
      });
      return () => {
          stop1();
          stop2();
      };
  }

  /**
   * Explicitly define the deps of computed.
   *
   * @param source
   * @param fn
   */
  function controlledComputed(source, fn) {
      const v = vueDemi.ref(fn());
      vueDemi.watch(source, () => v.value = fn(), {
          flush: 'sync',
      });
      return vueDemi.computed(() => v.value);
  }

  /*! *****************************************************************************
  Copyright (c) Microsoft Corporation.

  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.

  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** */

  function __rest(s, e) {
      var t = {};
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
          t[p] = s[p];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
          for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
              if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                  t[p[i]] = s[p[i]];
          }
      return t;
  }

  const isClient = typeof window !== 'undefined';
  const isDef = (val) => typeof val !== 'undefined';
  const assert = (condition, ...infos) => {
      if (!condition)
          console.warn(...infos);
  };
  const toString = Object.prototype.toString;
  const isBoolean = (val) => typeof val === 'boolean';
  const isFunction = (val) => typeof val === 'function';
  const isNumber = (val) => typeof val === 'number';
  const isString = (val) => typeof val === 'string';
  const isObject = (val) => toString.call(val) === '[object Object]';
  const isWindow = (val) => typeof window !== 'undefined' && toString.call(val) === '[object Window]';
  const now = () => Date.now();
  const timestamp = () => +Date.now();
  const clamp = (n, min, max) => Math.min(max, Math.max(min, n));
  const noop = () => { };

  /**
   * @internal
   */
  function createFilterWrapper(filter, fn) {
      function wrapper(...args) {
          filter(() => fn.apply(this, args), { fn, thisArg: this, args });
      }
      return wrapper;
  }
  const bypassFilter = (invoke) => {
      return invoke();
  };
  /**
   * Create an EventFilter that debounce the events
   *
   * @param ms
   */
  function debounceFilter(ms) {
      if (ms <= 0)
          return bypassFilter;
      let timer;
      const filter = (invoke) => {
          if (timer)
              clearTimeout(timer);
          timer = setTimeout(invoke, ms);
      };
      return filter;
  }
  /**
   * Create an EventFilter that throttle the events
   *
   * @param ms
   * @param [trailing=true]
   */
  function throttleFilter(ms, trailing = true) {
      if (ms <= 0)
          return bypassFilter;
      let lastExec = 0;
      let timer;
      const clear = () => {
          if (timer) {
              clearTimeout(timer);
              timer = undefined;
          }
      };
      const filter = (invoke) => {
          const elapsed = Date.now() - lastExec;
          clear();
          if (elapsed > ms) {
              lastExec = Date.now();
              invoke();
          }
          else if (trailing) {
              timer = setTimeout(() => {
                  clear();
                  invoke();
              }, ms);
          }
      };
      return filter;
  }
  /**
   * EventFilter that gives extra controls to pause and resume the filter
   *
   * @param extendFilter  Extra filter to apply when the PauseableFilter is active, default to none
   *
   */
  function pausableFilter(extendFilter = bypassFilter) {
      const isActive = vueDemi.ref(true);
      function pause() {
          isActive.value = false;
      }
      function resume() {
          isActive.value = true;
      }
      const eventFilter = (...args) => {
          if (isActive.value)
              extendFilter(...args);
      };
      return { isActive, pause, resume, eventFilter };
  }

  function promiseTimeout(ms, throwOnTimeout = false, reason = 'Timeout') {
      return new Promise((resolve, reject) => {
          if (throwOnTimeout)
              setTimeout(() => reject(reason), ms);
          else
              setTimeout(resolve, ms);
      });
  }
  function invoke(fn) {
      return fn();
  }

  // implementation
  function watchWithFilter(source, cb, options = {}) {
      const { eventFilter = bypassFilter } = options, watchOptions = __rest(options, ["eventFilter"]);
      return vueDemi.watch(source, createFilterWrapper(eventFilter, cb), watchOptions);
  }

  // implementation
  function debouncedWatch(source, cb, options = {}) {
      const { debounce = 0 } = options, watchOptions = __rest(options, ["debounce"]);
      return watchWithFilter(source, cb, Object.assign(Object.assign({}, watchOptions), { eventFilter: debounceFilter(debounce) }));
  }

  // implementation
  function extendRef(ref, extend, { enumerable = false, unwrap = true } = {}) {
      for (const [key, value] of Object.entries(extend)) {
          if (key === 'value')
              continue;
          if (vueDemi.isRef(value) && unwrap) {
              Object.defineProperty(ref, key, {
                  get() {
                      return value.value;
                  },
                  set(v) {
                      value.value = v;
                  },
                  enumerable,
              });
          }
          else {
              Object.defineProperty(ref, key, { value, enumerable });
          }
      }
      return ref;
  }

  function ignorableWatch(source, cb, options = {}) {
      const { eventFilter = bypassFilter } = options, watchOptions = __rest(options, ["eventFilter"]);
      const filteredCb = createFilterWrapper(eventFilter, cb);
      let ignoreUpdates;
      let ignorePrevAsyncUpdates;
      let stop;
      if (watchOptions.flush === 'sync') {
          const ignore = vueDemi.ref(false);
          // no op for flush: sync
          ignorePrevAsyncUpdates = () => { };
          ignoreUpdates = (updater) => {
              // Call the updater function and count how many sync updates are performed,
              // then add them to the ignore count
              ignore.value = true;
              updater();
              ignore.value = false;
          };
          stop = vueDemi.watch(source, (...args) => {
              if (!ignore.value)
                  filteredCb(...args);
          }, watchOptions);
      }
      else {
          // flush 'pre' and 'post'
          const disposables = [];
          // counters for how many following changes to be ignored
          // ignoreCounter is incremented before there is a history operation
          // affecting the source ref value (undo, redo, revert).
          // syncCounter is incremented in sync with every change to the
          // source ref value. This let us know how many times the ref
          // was modified and support chained sync operations. If there
          // are more sync triggers than the ignore count, the we now
          // there are modifications in the source ref value that we
          // need to commit
          const ignoreCounter = vueDemi.ref(0);
          const syncCounter = vueDemi.ref(0);
          ignorePrevAsyncUpdates = () => {
              ignoreCounter.value = syncCounter.value;
          };
          // Sync watch to count modifications to the source
          disposables.push(vueDemi.watch(source, () => {
              syncCounter.value++;
          }, Object.assign(Object.assign({}, watchOptions), { flush: 'sync' })));
          ignoreUpdates = (updater) => {
              // Call the updater function and count how many sync updates are performed,
              // then add them to the ignore count
              const syncCounterPrev = syncCounter.value;
              updater();
              ignoreCounter.value += syncCounter.value - syncCounterPrev;
          };
          disposables.push(vueDemi.watch(source, (...args) => {
              // If a history operation was performed (ignoreCounter > 0) and there are
              // no other changes to the source ref value afterwards, then ignore this commit
              const ignore = ignoreCounter.value > 0 && ignoreCounter.value === syncCounter.value;
              ignoreCounter.value = 0;
              syncCounter.value = 0;
              if (ignore)
                  return;
              filteredCb(...args);
          }, watchOptions));
          stop = () => {
              disposables.forEach(fn => fn());
          };
      }
      return { stop, ignoreUpdates, ignorePrevAsyncUpdates };
  }

  function makeDestructurable(obj, arr) {
      if (typeof Symbol !== 'undefined') {
          const clone = Object.assign({}, obj);
          Object.defineProperty(clone, Symbol.iterator, {
              enumerable: false,
              value() {
                  let index = 0;
                  return {
                      next: () => ({
                          value: arr[index++],
                          done: index > arr.length,
                      }),
                  };
              },
          });
          return clone;
      }
      else {
          return Object.assign([...arr], obj);
      }
  }

  // implementation
  function pausableWatch(source, cb, options = {}) {
      const { eventFilter: filter } = options, watchOptions = __rest(options, ["eventFilter"]);
      const { eventFilter, pause, resume, isActive } = pausableFilter(filter);
      const stop = watchWithFilter(source, cb, Object.assign(Object.assign({}, watchOptions), { eventFilter }));
      return { stop, pause, resume, isActive };
  }

  /**
   * Keep target ref(s) in sync with the source ref
   *
   * @param source source ref
   * @param targets
   */
  function syncRef(source, targets, { flush = 'sync', deep = false, immediate = true, } = {}) {
      if (!Array.isArray(targets))
          targets = [targets];
      return vueDemi.watch(source, (newValue) => {
          targets.forEach(target => target.value = newValue);
      }, {
          flush,
          deep,
          immediate,
      });
  }

  // implementation
  function throttledWatch(source, cb, options = {}) {
      const { throttle = 0 } = options, watchOptions = __rest(options, ["throttle"]);
      return watchWithFilter(source, cb, Object.assign(Object.assign({}, watchOptions), { eventFilter: throttleFilter(throttle) }));
  }

  /**
   * Call onMounted() if it's inside a component lifecycle, if not, run just call the function
   *
   * @param fn
   * @param sync if set to false, it will run in the nextTick() of Vue
   */
  function tryOnMounted(fn, sync = true) {
      if (vueDemi.getCurrentInstance())
          vueDemi.onMounted(fn);
      else if (sync)
          fn();
      else
          vueDemi.nextTick(fn);
  }

  /**
   * Call onUnmounted() if it's inside a component lifecycle, if not, do nothing
   *
   * @param fn
   */
  function tryOnUnmounted(fn) {
      if (vueDemi.getCurrentInstance())
          vueDemi.onUnmounted(fn);
  }

  /**
   * Basic counter with utility functions.
   *
   * @see   {@link https://vueuse.js.org/useCounter}
   * @param [initialValue=0]
   */
  function useCounter(initialValue = 0) {
      const count = vueDemi.ref(initialValue);
      const inc = (delta = 1) => (count.value += delta);
      const dec = (delta = 1) => (count.value -= delta);
      const get = () => count.value;
      const set = (val) => (count.value = val);
      const reset = (val = initialValue) => {
          initialValue = val;
          return set(val);
      };
      return { count, inc, dec, get, set, reset };
  }

  /**
   * Debounce execution of a function.
   *
   * @param  fn          A function to be executed after delay milliseconds debounced.
   * @param  ms          A zero-or-greater delay in milliseconds. For event callbacks, values around 100 or 250 (or even higher) are most useful.
   *
   * @return A new, debounce, function.
   */
  function useDebounceFn(fn, ms = 200) {
      return createFilterWrapper(debounceFilter(ms), fn);
  }

  function useDebounce(value, ms = 200) {
      if (ms <= 0)
          return value;
      const debounced = vueDemi.ref(value.value);
      const updater = useDebounceFn(() => {
          debounced.value = value.value;
      }, ms);
      vueDemi.watch(value, () => updater());
      return debounced;
  }

  /**
   * Wrapper for `setInterval` with controls
   *
   * @param cb
   * @param interval
   * @param immediate
   */
  function useIntervalFn(cb, interval = 1000, immediate = true) {
      let timer = null;
      const isActive = vueDemi.ref(false);
      function clean() {
          if (timer) {
              clearInterval(timer);
              timer = null;
          }
      }
      function pause() {
          isActive.value = false;
          clean();
      }
      function resume() {
          isActive.value = true;
          clean();
          timer = setInterval(cb, interval);
      }
      if (immediate)
          resume();
      tryOnUnmounted(pause);
      return {
          isActive,
          pause,
          resume,
          start: resume,
          stop: pause,
      };
  }

  function useInterval(interval = 1000, immediate = true) {
      const counter = vueDemi.ref(0);
      return Object.assign({ counter }, useIntervalFn(() => counter.value += 1, interval, immediate));
  }

  /**
   * Throttle execution of a function. Especially useful for rate limiting
   * execution of handlers on events like resize and scroll.
   *
   * @param   fn             A function to be executed after delay milliseconds. The `this` context and all arguments are passed through, as-is,
   *                                    to `callback` when the throttled-function is executed.
   * @param   ms             A zero-or-greater delay in milliseconds. For event callbacks, values around 100 or 250 (or even higher) are most useful.
   *
   * @return  A new, throttled, function.
   */
  function useThrottleFn(fn, ms = 200, trailing = true) {
      return createFilterWrapper(throttleFilter(ms, trailing), fn);
  }

  /**
   * Throttle execution of a function. Especially useful for rate limiting
   * execution of handlers on events like resize and scroll.
   *
   * @param  delay  A zero-or-greater delay in milliseconds. For event callbacks, values around 100 or 250 (or even higher) are most useful.
   */
  function useThrottle(value, delay = 200) {
      if (delay <= 0)
          return value;
      const throttled = vueDemi.ref(value.value);
      const updater = useThrottleFn(() => {
          throttled.value = value.value;
      }, delay);
      vueDemi.watch(value, () => updater());
      return throttled;
  }

  /**
   * Wrapper for `setTimeout` with controls.
   *
   * @param cb
   * @param interval
   * @param immediate
   */
  function useTimeoutFn(cb, interval, immediate) {
      const isActive = vueDemi.ref(false);
      let timer = null;
      function clear() {
          if (timer) {
              clearTimeout(timer);
              timer = null;
          }
      }
      function stop() {
          isActive.value = false;
          clear();
      }
      function start() {
          clear();
          isActive.value = true;
          timer = setTimeout(() => {
              timer = null;
              cb();
          }, interval);
      }
      if (immediate)
          start();
      tryOnUnmounted(stop);
      return {
          isActive,
          start,
          stop,
      };
  }

  /**
   * Update value after a given time with controls.
   *
   * @param interval
   * @param immediate
   */
  function useTimeout(interval = 1000, immediate = true) {
      const ready = vueDemi.ref(false);
      const controls = useTimeoutFn(() => ready.value = true, interval, immediate);
      function stop() {
          ready.value = false;
          controls.stop();
      }
      function start() {
          ready.value = false;
          controls.start();
      }
      return {
          ready,
          isActive: controls.isActive,
          start,
          stop,
      };
  }

  /**
   * A boolean ref with a toggler
   *
   * @see   {@link https://vueuse.js.org/useToggle}
   * @param [initialValue=false]
   */
  function useToggle(initialValue = false) {
      const boolean = vueDemi.ref(initialValue);
      const toggle = () => (boolean.value = !boolean.value);
      return [boolean, toggle];
  }

  function when(r) {
      let isNot = false;
      function toMatch(condition, { flush = 'sync', deep = false, timeout, throwOnTimeout } = {}) {
          let stop = null;
          const watcher = new Promise((resolve) => {
              stop = vueDemi.watch(r, (v) => {
                  if (condition(v) === !isNot) {
                      stop === null || stop === void 0 ? void 0 : stop();
                      resolve();
                  }
              }, {
                  flush,
                  deep,
                  immediate: true,
              });
          });
          const promises = [watcher];
          if (timeout) {
              promises.push(promiseTimeout(timeout, throwOnTimeout).finally(() => {
                  stop === null || stop === void 0 ? void 0 : stop();
              }));
          }
          return Promise.race(promises);
      }
      function toBe(value, options) {
          return toMatch(v => v === vueDemi.unref(value), options);
      }
      function toBeTruthy(options) {
          return toMatch(v => Boolean(v), options);
      }
      function toBeNull(options) {
          return toBe(null, options);
      }
      function toBeUndefined(options) {
          return toBe(undefined, options);
      }
      function toBeNaN(options) {
          return toMatch(Number.isNaN, options);
      }
      function toContains(value, options) {
          return toMatch((v) => {
              const array = Array.from(v);
              return array.includes(value) || array.includes(vueDemi.unref(value));
          }, options);
      }
      function changed(options) {
          return changedTimes(1, options);
      }
      function changedTimes(n = 1, options) {
          let count = -1; // skip the immediate check
          return toMatch(() => {
              count += 1;
              return count >= n;
          }, options);
      }
      if (Array.isArray(vueDemi.unref(r))) {
          const instance = {
              toMatch,
              toContains,
              changed,
              changedTimes,
              get not() {
                  isNot = !isNot;
                  return this;
              },
          };
          return instance;
      }
      else {
          const instance = {
              toMatch,
              toBe,
              toBeTruthy,
              toBeNull,
              toBeNaN,
              toBeUndefined,
              changed,
              changedTimes,
              get not() {
                  isNot = !isNot;
                  return this;
              },
          };
          return instance;
      }
  }

  exports.assert = assert;
  exports.biSyncRef = biSyncRef;
  exports.bypassFilter = bypassFilter;
  exports.clamp = clamp;
  exports.controlledComputed = controlledComputed;
  exports.createFilterWrapper = createFilterWrapper;
  exports.debounceFilter = debounceFilter;
  exports.debouncedWatch = debouncedWatch;
  exports.extendRef = extendRef;
  exports.ignorableWatch = ignorableWatch;
  exports.invoke = invoke;
  exports.isBoolean = isBoolean;
  exports.isClient = isClient;
  exports.isDef = isDef;
  exports.isFunction = isFunction;
  exports.isNumber = isNumber;
  exports.isObject = isObject;
  exports.isString = isString;
  exports.isWindow = isWindow;
  exports.makeDestructurable = makeDestructurable;
  exports.noop = noop;
  exports.now = now;
  exports.pausableFilter = pausableFilter;
  exports.pausableWatch = pausableWatch;
  exports.promiseTimeout = promiseTimeout;
  exports.syncRef = syncRef;
  exports.throttleFilter = throttleFilter;
  exports.throttledWatch = throttledWatch;
  exports.timestamp = timestamp;
  exports.tryOnMounted = tryOnMounted;
  exports.tryOnUnmounted = tryOnUnmounted;
  exports.useCounter = useCounter;
  exports.useDebounce = useDebounce;
  exports.useDebounceFn = useDebounceFn;
  exports.useInterval = useInterval;
  exports.useIntervalFn = useIntervalFn;
  exports.useThrottle = useThrottle;
  exports.useThrottleFn = useThrottleFn;
  exports.useTimeout = useTimeout;
  exports.useTimeoutFn = useTimeoutFn;
  exports.useToggle = useToggle;
  exports.watchWithFilter = watchWithFilter;
  exports.when = when;

  Object.defineProperty(exports, '__esModule', { value: true });

})));
