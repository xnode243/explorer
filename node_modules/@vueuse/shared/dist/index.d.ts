import { Ref, WatchSource, ComputedRef as ComputedRef$1, WatchOptions, WatchCallback, WatchStopHandle, ShallowUnwrapRef as ShallowUnwrapRef$1 } from 'vue-demi';
import { ComputedRef, WatchStopHandle as WatchStopHandle$1, Ref as Ref$1 } from 'vue-demi';

/**
 * Two-way refs synchronization.
 *
 * @param a
 * @param b
 */
declare function biSyncRef<R extends Ref<any>>(a: R, b: R): () => void;

/**
 * Explicitly define the deps of computed.
 *
 * @param source
 * @param fn
 */
declare function controlledComputed<T, S>(source: WatchSource<S>, fn: () => T): ComputedRef<T>;

declare const isClient: boolean;
declare const isDef: <T = any>(val?: T | undefined) => val is T;
declare const assert: (condition: boolean, ...infos: any[]) => void;
declare const isBoolean: (val: any) => val is boolean;
declare const isFunction: <T = Function>(val: any) => val is T;
declare const isNumber: (val: any) => val is number;
declare const isString: (val: unknown) => val is string;
declare const isObject: (val: any) => val is object;
declare const isWindow: (val: any) => val is Window;
declare const now: () => number;
declare const timestamp: () => number;
declare const clamp: (n: number, min: number, max: number) => number;
declare const noop: () => void;

declare type Fn = () => void;
declare type MaybeRef<T> = T | Ref<T> | ComputedRef$1<T>;
declare type ElementOf<T> = T extends (infer E)[] ? E : never;
declare type ShallowUnwrapRef<T> = T extends Ref<infer P> ? P : T;
interface Pausable {
    /**
     * A ref indicate whether a pusable instance is active
     */
    isActive: Ref<boolean>;
    /**
     * Temporary pause the effect from executing
     */
    pause: Fn;
    /**
     * Resume the effects
     */
    resume: Fn;
}
interface ConfigurableFlush {
    /**
     * Timing for monitoring changes, refer to WatchOptions for more details
     *
     * @default 'pre'
     */
    flush?: WatchOptions['flush'];
}
interface ConfigurableFlushSync {
    /**
     * Timing for monitoring changes, refer to WatchOptions for more details.
     * Unlike `watch()`, the default is set to `sync`
     *
     * @default 'sync'
     */
    flush?: WatchOptions['flush'];
}
declare type MapSources<T> = {
    [K in keyof T]: T[K] extends WatchSource<infer V> ? V : never;
};
declare type MapOldSources<T, Immediate> = {
    [K in keyof T]: T[K] extends WatchSource<infer V> ? Immediate extends true ? V | undefined : V : never;
};

declare type FunctionArgs<Args extends any[] = any[], Return = void> = (...args: Args) => Return;
interface FunctionWrapperOptions<Args extends any[] = any[], This = any> {
    fn: FunctionArgs<Args, This>;
    args: Args;
    thisArg: This;
}
declare type EventFilter<Args extends any[] = any[], This = any> = (invoke: Fn, options: FunctionWrapperOptions<Args, This>) => void;
interface ConfigurableEventFilter {
    eventFilter?: EventFilter;
}
/**
 * @internal
 */
declare function createFilterWrapper<T extends FunctionArgs>(filter: EventFilter, fn: T): T;
declare const bypassFilter: EventFilter;
/**
 * Create an EventFilter that debounce the events
 *
 * @param ms
 */
declare function debounceFilter(ms: number): EventFilter<any[], any>;
/**
 * Create an EventFilter that throttle the events
 *
 * @param ms
 * @param [trailing=true]
 */
declare function throttleFilter(ms: number, trailing?: boolean): EventFilter<any[], any>;
/**
 * EventFilter that gives extra controls to pause and resume the filter
 *
 * @param extendFilter  Extra filter to apply when the PauseableFilter is active, default to none
 *
 */
declare function pausableFilter(extendFilter?: EventFilter): Pausable & {
    eventFilter: EventFilter;
};

declare function promiseTimeout(ms: number, throwOnTimeout?: boolean, reason?: string): Promise<void>;
declare function invoke<T>(fn: () => T): T;

interface DebouncedWatchOptions<Immediate> extends WatchOptions<Immediate> {
    debounce?: number;
}
declare function debouncedWatch<T extends Readonly<WatchSource<unknown>[]>, Immediate extends Readonly<boolean> = false>(sources: T, cb: WatchCallback<MapSources<T>, MapOldSources<T, Immediate>>, options?: DebouncedWatchOptions<Immediate>): WatchStopHandle;
declare function debouncedWatch<T, Immediate extends Readonly<boolean> = false>(source: WatchSource<T>, cb: WatchCallback<T, Immediate extends true ? T | undefined : T>, options?: DebouncedWatchOptions<Immediate>): WatchStopHandle;
declare function debouncedWatch<T extends object, Immediate extends Readonly<boolean> = false>(source: T, cb: WatchCallback<T, Immediate extends true ? T | undefined : T>, options?: DebouncedWatchOptions<Immediate>): WatchStopHandle;

interface ExtendRefOptions<Unwrap extends boolean = boolean> {
    /**
     * Is the extends properties enumerable
     *
     * @default false
     */
    enumerable?: boolean;
    /**
     * Unwrap for Ref properties
     *
     * @default true
     */
    unwrap?: Unwrap;
}
/**
 * Overlad 1: Unwrap set to false
 */
declare function extendRef<R extends Ref<any>, Extend extends object, Options extends ExtendRefOptions<false>>(ref: R, extend: Extend, options: Options): ShallowUnwrapRef$1<Extend> & R;
/**
 * Overlad 2: Unwrap unset or set to true
 */
declare function extendRef<R extends Ref<any>, Extend extends object, Options extends ExtendRefOptions>(ref: R, extend: Extend, options: Options): Extend & R;

interface WatchWithFilterOptions<Immediate> extends WatchOptions<Immediate>, ConfigurableEventFilter {
}
declare function watchWithFilter<T extends Readonly<WatchSource<unknown>[]>, Immediate extends Readonly<boolean> = false>(sources: T, cb: WatchCallback<MapSources<T>, MapOldSources<T, Immediate>>, options?: WatchWithFilterOptions<Immediate>): WatchStopHandle;
declare function watchWithFilter<T, Immediate extends Readonly<boolean> = false>(source: WatchSource<T>, cb: WatchCallback<T, Immediate extends true ? T | undefined : T>, options?: WatchWithFilterOptions<Immediate>): WatchStopHandle;
declare function watchWithFilter<T extends object, Immediate extends Readonly<boolean> = false>(source: T, cb: WatchCallback<T, Immediate extends true ? T | undefined : T>, options?: WatchWithFilterOptions<Immediate>): WatchStopHandle;

declare type IgnoredUpdater = (updater: () => void) => void;
interface IgnorableWatchReturn {
    ignoreUpdates: IgnoredUpdater;
    ignorePrevAsyncUpdates: () => void;
    stop: WatchStopHandle;
}
declare function ignorableWatch<T extends Readonly<WatchSource<unknown>[]>, Immediate extends Readonly<boolean> = false>(sources: T, cb: WatchCallback<MapSources<T>, MapOldSources<T, Immediate>>, options?: WatchWithFilterOptions<Immediate>): IgnorableWatchReturn;
declare function ignorableWatch<T, Immediate extends Readonly<boolean> = false>(source: WatchSource<T>, cb: WatchCallback<T, Immediate extends true ? T | undefined : T>, options?: WatchWithFilterOptions<Immediate>): IgnorableWatchReturn;
declare function ignorableWatch<T extends object, Immediate extends Readonly<boolean> = false>(source: T, cb: WatchCallback<T, Immediate extends true ? T | undefined : T>, options?: WatchWithFilterOptions<Immediate>): IgnorableWatchReturn;

declare function makeDestructurable<T extends Record<string, unknown>, A extends readonly any[]>(obj: T, arr: A): T & A;

interface PausableWatchReturn extends Pausable {
    stop: WatchStopHandle;
}
declare function pausableWatch<T extends Readonly<WatchSource<unknown>[]>, Immediate extends Readonly<boolean> = false>(sources: T, cb: WatchCallback<MapSources<T>, MapOldSources<T, Immediate>>, options?: WatchWithFilterOptions<Immediate>): PausableWatchReturn;
declare function pausableWatch<T, Immediate extends Readonly<boolean> = false>(source: WatchSource<T>, cb: WatchCallback<T, Immediate extends true ? T | undefined : T>, options?: WatchWithFilterOptions<Immediate>): PausableWatchReturn;
declare function pausableWatch<T extends object, Immediate extends Readonly<boolean> = false>(source: T, cb: WatchCallback<T, Immediate extends true ? T | undefined : T>, options?: WatchWithFilterOptions<Immediate>): PausableWatchReturn;

interface SyncRefOptions extends ConfigurableFlushSync {
    /**
     * Watch deeply
     *
     * @default false
     */
    deep?: boolean;
    /**
     * Sync values immediately
     *
     * @default true
     */
    immediate?: boolean;
}
/**
 * Keep target ref(s) in sync with the source ref
 *
 * @param source source ref
 * @param targets
 */
declare function syncRef<R extends Ref<any>>(source: R, targets: R | R[], { flush, deep, immediate, }?: SyncRefOptions): WatchStopHandle$1;

interface ThrottledWatchOptions<Immediate> extends WatchOptions<Immediate> {
    throttle?: number;
}
declare function throttledWatch<T extends Readonly<WatchSource<unknown>[]>, Immediate extends Readonly<boolean> = false>(sources: T, cb: WatchCallback<MapSources<T>, MapOldSources<T, Immediate>>, options?: ThrottledWatchOptions<Immediate>): WatchStopHandle;
declare function throttledWatch<T, Immediate extends Readonly<boolean> = false>(source: WatchSource<T>, cb: WatchCallback<T, Immediate extends true ? T | undefined : T>, options?: ThrottledWatchOptions<Immediate>): WatchStopHandle;
declare function throttledWatch<T extends object, Immediate extends Readonly<boolean> = false>(source: T, cb: WatchCallback<T, Immediate extends true ? T | undefined : T>, options?: ThrottledWatchOptions<Immediate>): WatchStopHandle;

/**
 * Call onMounted() if it's inside a component lifecycle, if not, run just call the function
 *
 * @param fn
 * @param sync if set to false, it will run in the nextTick() of Vue
 */
declare function tryOnMounted(fn: Fn, sync?: boolean): void;

/**
 * Call onUnmounted() if it's inside a component lifecycle, if not, do nothing
 *
 * @param fn
 */
declare function tryOnUnmounted(fn: Fn): void;

/**
 * Basic counter with utility functions.
 *
 * @see   {@link https://vueuse.js.org/useCounter}
 * @param [initialValue=0]
 */
declare function useCounter(initialValue?: number): {
    count: Ref$1<number>;
    inc: (delta?: number) => number;
    dec: (delta?: number) => number;
    get: () => number;
    set: (val: number) => number;
    reset: (val?: number) => number;
};

declare function useDebounce<T>(value: Ref<T>, ms?: number): Ref<T>;

/**
 * Debounce execution of a function.
 *
 * @param  fn          A function to be executed after delay milliseconds debounced.
 * @param  ms          A zero-or-greater delay in milliseconds. For event callbacks, values around 100 or 250 (or even higher) are most useful.
 *
 * @return A new, debounce, function.
 */
declare function useDebounceFn<T extends FunctionArgs>(fn: T, ms?: number): T;

declare function useInterval(interval?: number, immediate?: boolean): {
    stop: Fn;
    start: Fn;
    isActive: Ref$1<boolean>;
    pause: Fn;
    resume: Fn;
    counter: Ref$1<number>;
};

interface IntervalFnReturn extends Pausable {
    /**
     * @deprecated use pause() instead
     */
    stop: Fn;
    /**
     * @deprecated use resume() instead
     */
    start: Fn;
}
/**
 * Wrapper for `setInterval` with controls
 *
 * @param cb
 * @param interval
 * @param immediate
 */
declare function useIntervalFn(cb: Fn, interval?: number, immediate?: boolean): IntervalFnReturn;

/**
 * Throttle execution of a function. Especially useful for rate limiting
 * execution of handlers on events like resize and scroll.
 *
 * @param  delay  A zero-or-greater delay in milliseconds. For event callbacks, values around 100 or 250 (or even higher) are most useful.
 */
declare function useThrottle<T>(value: Ref<T>, delay?: number): Ref<T>;

/**
 * Throttle execution of a function. Especially useful for rate limiting
 * execution of handlers on events like resize and scroll.
 *
 * @param   fn             A function to be executed after delay milliseconds. The `this` context and all arguments are passed through, as-is,
 *                                    to `callback` when the throttled-function is executed.
 * @param   ms             A zero-or-greater delay in milliseconds. For event callbacks, values around 100 or 250 (or even higher) are most useful.
 *
 * @return  A new, throttled, function.
 */
declare function useThrottleFn<T extends FunctionArgs>(fn: T, ms?: number, trailing?: boolean): T;

/**
 * Update value after a given time with controls.
 *
 * @param interval
 * @param immediate
 */
declare function useTimeout(interval?: number, immediate?: boolean): {
    ready: Ref$1<boolean>;
    isActive: Ref$1<boolean>;
    start: () => void;
    stop: () => void;
};

/**
 * Wrapper for `setTimeout` with controls.
 *
 * @param cb
 * @param interval
 * @param immediate
 */
declare function useTimeoutFn(cb: () => any, interval?: number, immediate?: boolean): {
    isActive: Ref$1<boolean>;
    start: () => void;
    stop: () => void;
};

/**
 * A boolean ref with a toggler
 *
 * @see   {@link https://vueuse.js.org/useToggle}
 * @param [initialValue=false]
 */
declare function useToggle(initialValue?: boolean): readonly [Ref$1<boolean>, () => boolean];

interface WhenToMatchOptions {
    /**
     * Milseconds timeout for promise to resolve/reject if the when condition does not meet.
     * 0 for never timed out
     *
     * @default 0
     */
    timeout?: number;
    /**
     * Reject the promise when timeout
     *
     * @default false
     */
    throwOnTimeout?: boolean;
    /**
     * `flush` option for internal watch
     *
     * @default 'sync'
     */
    flush?: WatchOptions['flush'];
    /**
     * `deep` option for internal watch
     *
     * @default 'false'
     */
    deep?: WatchOptions['deep'];
}
interface BaseWhenInstance<T> {
    toMatch(condition: (v: T) => boolean, options?: WhenToMatchOptions): Promise<void>;
    changed(options?: WhenToMatchOptions): Promise<void>;
    changedTimes(n?: number, options?: WhenToMatchOptions): Promise<void>;
}
interface ValueWhenInstance<T> extends BaseWhenInstance<T> {
    readonly not: ValueWhenInstance<T>;
    toBe<P = T>(value: MaybeRef<T | P>, options?: WhenToMatchOptions): Promise<void>;
    toBeTruthy(options?: WhenToMatchOptions): Promise<void>;
    toBeNull(options?: WhenToMatchOptions): Promise<void>;
    toBeUndefined(options?: WhenToMatchOptions): Promise<void>;
    toBeNaN(options?: WhenToMatchOptions): Promise<void>;
}
interface ArrayWhenInstance<T> extends BaseWhenInstance<T> {
    readonly not: ArrayWhenInstance<T>;
    toContains(value: MaybeRef<ElementOf<ShallowUnwrapRef<T>>>, options?: WhenToMatchOptions): Promise<void>;
}
declare function when<T extends unknown[]>(r: T): ArrayWhenInstance<T>;
declare function when<T extends Ref<unknown[]>>(r: T): ArrayWhenInstance<T>;
declare function when<T>(r: WatchSource<T>): ValueWhenInstance<T>;
declare function when<T>(r: T): ValueWhenInstance<T>;

export { ArrayWhenInstance, BaseWhenInstance, ConfigurableEventFilter, ConfigurableFlush, ConfigurableFlushSync, DebouncedWatchOptions, ElementOf, EventFilter, ExtendRefOptions, Fn, FunctionArgs, FunctionWrapperOptions, IgnorableWatchReturn, IgnoredUpdater, IntervalFnReturn, MapOldSources, MapSources, MaybeRef, Pausable, PausableWatchReturn, ShallowUnwrapRef, SyncRefOptions, ThrottledWatchOptions, ValueWhenInstance, WatchWithFilterOptions, WhenToMatchOptions, assert, biSyncRef, bypassFilter, clamp, controlledComputed, createFilterWrapper, debounceFilter, debouncedWatch, extendRef, ignorableWatch, invoke, isBoolean, isClient, isDef, isFunction, isNumber, isObject, isString, isWindow, makeDestructurable, noop, now, pausableFilter, pausableWatch, promiseTimeout, syncRef, throttleFilter, throttledWatch, timestamp, tryOnMounted, tryOnUnmounted, useCounter, useDebounce, useDebounceFn, useInterval, useIntervalFn, useThrottle, useThrottleFn, useTimeout, useTimeoutFn, useToggle, watchWithFilter, when };
