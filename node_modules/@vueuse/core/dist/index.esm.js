import { isRef, ref, watchEffect, computed, createApp, reactive, unref, watch, markRaw, getCurrentInstance, isVue3 } from 'vue-demi';
import { isClient, isString, tryOnUnmounted, tryOnMounted, createFilterWrapper, bypassFilter, throttleFilter, timestamp, watchWithFilter, isFunction, noop, pausableFilter, ignorableWatch, clamp } from '@vueuse/shared';
export * from '@vueuse/shared';

/**
 * Create an asynchronous computed dependency.
 *
 * @see   {@link https://vueuse.js.org/asyncComputed}
 * @param evaluationCallback     The promise-returning callback which generates the computed value
 * @param initialState           The initial state, used until the first evaluation finishes
 * @param optionsOrRef           Additional options or a ref passed to receive the updates of the async evaluation
 */
function asyncComputed(evaluationCallback, initialState, optionsOrRef) {
    let options;
    if (isRef(optionsOrRef)) {
        options = {
            evaluating: optionsOrRef,
        };
    }
    else {
        options = optionsOrRef !== null && optionsOrRef !== void 0 ? optionsOrRef : {};
    }
    const { lazy = false, evaluating = undefined, } = options;
    const started = ref(!lazy);
    const current = ref(initialState);
    let counter = 0;
    watchEffect(async (onInvalidate) => {
        if (!started.value)
            return;
        counter++;
        const counterAtBeginning = counter;
        let hasFinished = false;
        try {
            // Defer initial setting of `evaluating` ref
            // to avoid having it as a dependency
            if (evaluating) {
                Promise.resolve().then(() => {
                    evaluating.value = true;
                });
            }
            const result = await evaluationCallback((cancelCallback) => {
                onInvalidate(() => {
                    if (evaluating)
                        evaluating.value = false;
                    if (!hasFinished)
                        cancelCallback();
                });
            });
            if (counterAtBeginning === counter)
                current.value = result;
        }
        finally {
            if (evaluating)
                evaluating.value = false;
            hasFinished = true;
        }
    });
    if (lazy) {
        return computed(() => {
            started.value = true;
            return current.value;
        });
    }
    else {
        return current;
    }
}

function withScope(factory) {
    const container = document.createElement('div');
    let state = null;
    createApp({
        setup() {
            state = reactive(factory());
        },
        render: () => null,
    }).mount(container);
    return state;
}
/**
 * Keep states in the global scope to be reusable across Vue instances.
 *
 * @see   {@link https://vueuse.js.org/createGlobalState}
 * @param stateFactory A factory function to create the state
 */
function createGlobalState(stateFactory) {
    let state;
    return () => {
        if (state == null)
            state = withScope(stateFactory);
        return state;
    };
}

const defaultWindow = /* #__PURE__ */ isClient ? window : undefined;
const defaultDocument = /* #__PURE__ */ isClient ? window.document : undefined;
const defaultNavigator = /* #__PURE__ */ isClient ? window.navigator : undefined;

function useEventListener(...args) {
    let target;
    let event;
    let listener;
    let options;
    if (isString(args[0])) {
        [event, listener, options] = args;
        target = defaultWindow;
    }
    else {
        [target, event, listener, options] = args;
    }
    if (!target)
        return;
    let stopped = false;
    target.addEventListener(event, listener, options);
    const stop = () => {
        if (stopped)
            return;
        target.removeEventListener(event, listener, options);
        stopped = true;
    };
    tryOnUnmounted(stop);
    return stop;
}

const events = ['mousedown', 'touchstart'];
/**
 * Listen for clicks outside of an element.
 *
 * @see   {@link https://vueuse.js.org/onClickOutside}
 * @param target
 * @param handler
 * @param options
 */
function onClickOutside(target, handler, options = {}) {
    const { window = defaultWindow } = options;
    if (!window)
        return;
    const targetRef = ref(target);
    const listener = (event) => {
        if (!targetRef.value)
            return;
        const elements = event.composedPath();
        if (targetRef.value === event.target || elements.includes(targetRef.value))
            return;
        handler(event);
    };
    let disposables = events
        .map(event => useEventListener(window, event, listener, { passive: true }));
    const stop = () => {
        disposables.forEach(stop => stop());
        disposables = [];
    };
    tryOnUnmounted(stop);
    return stop;
}

/* this implementation is original ported from https://github.com/streamich/react-use by Vadim Dalecky */
const isFocusedElementEditable = () => {
    const { activeElement, body } = document;
    if (!activeElement)
        return false;
    // If not element has focus, we assume it is not editable, too.
    if (activeElement === body)
        return false;
    // Assume <input> and <textarea> elements are editable.
    switch (activeElement.tagName) {
        case 'INPUT':
        case 'TEXTAREA':
            return true;
    }
    // Check if any other focused element id editable.
    return activeElement.hasAttribute('contenteditable');
};
const isTypedCharGood = ({ keyCode, metaKey, ctrlKey, altKey, }) => {
    if (metaKey || ctrlKey || altKey)
        return false;
    // 0...9
    if ((keyCode >= 48 && keyCode <= 57) || (keyCode >= 96 && keyCode <= 105))
        return true;
    // a...z
    if (keyCode >= 65 && keyCode <= 90)
        return true;
    // All other keys.
    return false;
};
/**
 * Fires when users start typing on non-editable elements.
 *
 * @see   {@link https://vueuse.js.org/onStartTyping}
 * @param callback
 * @param options
 */
function onStartTyping(callback, { document = defaultDocument } = {}) {
    const keydown = (event) => {
        !isFocusedElementEditable()
            && isTypedCharGood(event)
            && callback(event);
    };
    if (document)
        useEventListener(document, 'keydown', keydown, { passive: true });
}

/**
 * Reactive async state. Will not block your setup function and will triggers changes once
 * the promise is ready.
 *
 * @see   {@link https://vueuse.js.org/useAsyncState}
 * @param promise         The promise / async function to be resolved
 * @param initialState    The initial state, used until the first evaluation finishes
 * @param delay           Delay (ms)
 * @param catchFn         Error handling callback
 */
function useAsyncState(promise, initialState, delay = 0, catchFn = (e) => { }) {
    const state = ref(initialState);
    const ready = ref(false);
    function run() {
        promise
            .then((data) => {
            // @ts-ignore
            state.value = data;
            ready.value = true;
        })
            .catch(catchFn);
    }
    if (!delay)
        run();
    else
        setTimeout(run, delay);
    return { state, ready };
}

/* this implementation is original ported from https://github.com/logaretm/vue-use-web by Abdelrahman Awad */
/**
 * Reactive Battery Status API.
 *
 * @see   {@link https://vueuse.js.org/useBattery}
 * @param options
 */
function useBattery({ navigator = defaultNavigator } = {}) {
    const events = ['chargingchange', 'chargingtimechange', 'dischargingtimechange', 'levelchange'];
    const isSupported = navigator && 'getBattery' in navigator;
    const charging = ref(false);
    const chargingTime = ref(0);
    const dischargingTime = ref(0);
    const level = ref(1);
    let battery;
    function updateBatteryInfo() {
        charging.value = this.charging;
        chargingTime.value = this.chargingTime || 0;
        dischargingTime.value = this.dischargingTime || 0;
        level.value = this.level;
    }
    if (isSupported) {
        navigator
            .getBattery()
            .then((_battery) => {
            battery = _battery;
            updateBatteryInfo.call(battery);
            for (const event of events)
                useEventListener(battery, event, updateBatteryInfo, { passive: true });
        });
    }
    return {
        isSupported,
        charging,
        chargingTime,
        dischargingTime,
        level,
    };
}

/* this implementation is original ported from https://github.com/logaretm/vue-use-web by Abdelrahman Awad */
/**
 * Reactive browser location.
 *
 * @see   {@link https://vueuse.js.org/useBrowserLocation}
 * @param options
 */
function useBrowserLocation({ window = defaultWindow } = {}) {
    const buildState = (trigger) => {
        const { state, length } = (window === null || window === void 0 ? void 0 : window.history) || {};
        const { hash, host, hostname, href, origin, pathname, port, protocol, search } = (window === null || window === void 0 ? void 0 : window.location) || {};
        return {
            trigger,
            state,
            length,
            hash,
            host,
            hostname,
            href,
            origin,
            pathname,
            port,
            protocol,
            search,
        };
    };
    const state = ref(buildState('load'));
    if (window)
        useEventListener(window, 'popstate', () => state.value = buildState('popstate'), { passive: true });
    return state;
}

/* this implementation is original ported from https://github.com/logaretm/vue-use-web by Abdelrahman Awad */
/**
 * Reactive Clipboard API.
 *
 * @see   {@link https://vueuse.js.org/useClipboard}
 * @param options
 */
function useClipboard({ navigator = defaultNavigator } = {}) {
    const events = ['copy', 'cut'];
    const isSupported = navigator && 'clipboard' in navigator;
    const text = ref('');
    function updateText() {
        // @ts-expect-error untyped API
        navigator.clipboard.readText().then((value) => {
            text.value = value;
        });
    }
    if (isSupported) {
        for (const event of events)
            useEventListener(event, updateText);
    }
    async function copy(txt) {
        if (isSupported) {
            // @ts-expect-error untyped API
            await navigator.clipboard.writeText(txt);
            text.value = txt;
        }
    }
    return {
        isSupported,
        text,
        copy,
    };
}

/**
 * Manipulate CSS variables.
 *
 * @see   {@link https://vueuse.js.org/useCssVar}
 * @param prop
 * @param el
 * @param options
 */
function useCssVar(prop, el, { window = defaultWindow } = {}) {
    if (!window)
        return ref('');
    const varRef = ref('');
    const elRef = ref(unref(el) || window.document.documentElement);
    tryOnMounted(() => {
        varRef.value = window.getComputedStyle(elRef.value).getPropertyValue(prop);
    });
    watch(varRef, (val) => {
        var _a;
        if ((_a = elRef.value) === null || _a === void 0 ? void 0 : _a.style)
            elRef.value.style.setProperty(prop, val);
    });
    return varRef;
}

/* this implementation is original ported from https://github.com/logaretm/vue-use-web by Abdelrahman Awad */
/**
 * Reactive DeviceLightEvent.
 *
 * @see   {@link https://vueuse.js.org/useDeviceLight}
 * @param options
 */
function useDeviceLight({ window = defaultWindow } = {}) {
    const light = ref(null);
    if (window) {
        useEventListener(window, 'devicelight', (event) => {
            light.value = event.value;
        });
    }
    return light;
}

/* this implementation is original ported from https://github.com/logaretm/vue-use-web by Abdelrahman Awad */
/**
 * Reactive DeviceMotionEvent.
 *
 * @see   {@link https://vueuse.js.org/useDeviceMotion}
 * @param options
 */
function useDeviceMotion(options = {}) {
    const { window = defaultWindow, eventFilter = bypassFilter, } = options;
    const acceleration = ref({ x: null, y: null, z: null });
    const rotationRate = ref({ alpha: null, beta: null, gamma: null });
    const interval = ref(0);
    const accelerationIncludingGravity = ref({
        x: null,
        y: null,
        z: null,
    });
    if (window) {
        const onDeviceMotion = createFilterWrapper(eventFilter, (event) => {
            acceleration.value = event.acceleration;
            accelerationIncludingGravity.value = event.accelerationIncludingGravity;
            rotationRate.value = event.rotationRate;
            interval.value = event.interval;
        });
        useEventListener(window, 'devicemotion', onDeviceMotion);
    }
    return {
        acceleration,
        accelerationIncludingGravity,
        rotationRate,
        interval,
    };
}

/* this implementation is original ported from https://github.com/logaretm/vue-use-web by Abdelrahman Awad */
/**
 * Reactive DeviceOrientationEvent.
 *
 * @see   {@link https://vueuse.js.org/useDeviceOrientation}
 * @param options
 */
function useDeviceOrientation(options = {}) {
    const { window = defaultWindow } = options;
    const isSupported = Boolean(window && 'DeviceOrientationEvent' in window);
    const isAbsolute = ref(false);
    const alpha = ref(null);
    const beta = ref(null);
    const gamma = ref(null);
    if (window && isSupported) {
        useEventListener(window, 'deviceorientation', (event) => {
            isAbsolute.value = event.absolute;
            alpha.value = event.alpha;
            beta.value = event.beta;
            gamma.value = event.gamma;
        });
    }
    return {
        isSupported,
        isAbsolute,
        alpha,
        beta,
        gamma,
    };
}

/* this implementation is original ported from https://github.com/logaretm/vue-use-web by Abdelrahman Awad */
/**
 * Reactive Media Query.
 *
 * @see   {@link https://vueuse.js.org/useMediaQuery}
 * @param query
 * @param options
 */
function useMediaQuery(query, options = {}) {
    const { window = defaultWindow } = options;
    if (!window)
        return ref(false);
    const mediaQuery = window.matchMedia(query);
    const matches = ref(mediaQuery.matches);
    const handler = (event) => {
        matches.value = event.matches;
    };
    if ('addEventListener' in mediaQuery) {
        mediaQuery.addEventListener('change', handler);
    }
    else {
        // @ts-expect-error - fallback for Safari < 14 and older browsers
        mediaQuery.addListener(handler);
    }
    tryOnUnmounted(() => {
        if ('removeEventListener' in mediaQuery) {
            mediaQuery.removeEventListener('change', handler);
        }
        else {
            // @ts-expect-error - fallback for Safari < 14 and older browsers
            mediaQuery.removeListener(handler);
        }
    });
    return matches;
}

// device pixel ratio statistics from https://www.mydevice.io/
const DEVICE_PIXEL_RATIO_SCALES = [
    1,
    1.325,
    1.4,
    1.5,
    1.8,
    2,
    2.4,
    2.5,
    2.75,
    3,
    3.5,
    4,
];
/**
 * Reactively track `window.devicePixelRatio`.
 *
 * @see   {@link https://vueuse.js.org/useDevicePixelRatio}
 * @param options
 */
function useDevicePixelRatio({ window = defaultWindow, } = {}) {
    if (!window) {
        return {
            pixelRatio: ref(1),
        };
    }
    const pixelRatio = ref(window.devicePixelRatio);
    const handleDevicePixelRatio = () => {
        pixelRatio.value = window.devicePixelRatio;
    };
    useEventListener(window, 'resize', handleDevicePixelRatio, { passive: true });
    DEVICE_PIXEL_RATIO_SCALES.forEach((dppx) => {
        // listen mql events in both sides
        const mqlMin = useMediaQuery(`screen and (min-resolution: ${dppx}dppx)`);
        const mqlMax = useMediaQuery(`screen and (max-resolution: ${dppx}dppx)`);
        watch([mqlMin, mqlMax], handleDevicePixelRatio);
    });
    return { pixelRatio };
}

/**
 * Reactively track `document.visibilityState`.
 *
 * @see   {@link https://vueuse.js.org/useDocumentVisibility}
 * @param options
 */
function useDocumentVisibility({ document = defaultDocument } = {}) {
    if (!document)
        return ref('visible');
    const visibility = ref(document.visibilityState);
    useEventListener(document, 'visibilitychange', () => {
        visibility.value = document.visibilityState;
    });
    return visibility;
}

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
}

/**
 * Reports changes to the dimensions of an Element's content or the border-box
 *
 * @see   {@link https://vueuse.js.org/useResizeObserver}
 * @param target
 * @param callback
 * @param options
 */
function useResizeObserver(target, callback, options = {}) {
    const { window = defaultWindow } = options, observerOptions = __rest(options, ["window"]);
    let observer;
    const targetRef = ref(target);
    const isSupported = window && 'ResizeObserver' in window;
    const cleanup = () => {
        if (observer) {
            observer.disconnect();
            observer = undefined;
        }
    };
    const stopWatch = watch(targetRef, (newValue) => {
        cleanup();
        if (isSupported && window && newValue) {
            // @ts-expect-error missing type
            observer = new window.ResizeObserver(callback);
            observer.observe(newValue, observerOptions);
        }
    }, { immediate: true });
    const stop = () => {
        cleanup();
        stopWatch();
    };
    tryOnUnmounted(stop);
    return {
        isSupported,
        stop,
    };
}

/**
 * Reactive size of an HTML element.
 *
 * @see   {@link https://vueuse.js.org/useElementSize}
 * @param target
 * @param callback
 * @param options
 */
function useElementBounding(target, options = {}) {
    const height = ref(0);
    const bottom = ref(0);
    const left = ref(0);
    const right = ref(0);
    const top = ref(0);
    const width = ref(0);
    const x = ref(0);
    const y = ref(0);
    useResizeObserver(target, ([entry]) => {
        height.value = entry.contentRect.height;
        bottom.value = entry.contentRect.bottom;
        left.value = entry.contentRect.left;
        right.value = entry.contentRect.right;
        top.value = entry.contentRect.top;
        width.value = entry.contentRect.width;
        x.value = entry.contentRect.x;
        y.value = entry.contentRect.y;
    }, options);
    return {
        x,
        y,
        top,
        right,
        bottom,
        left,
        width,
        height,
    };
}

/**
 * Reactive size of an HTML element.
 *
 * @see   {@link https://vueuse.js.org/useElementSize}
 * @param target
 * @param callback
 * @param options
 */
function useElementSize(target, initialSize = { width: 0, height: 0 }, options = {}) {
    const width = ref(initialSize.width);
    const height = ref(initialSize.height);
    useResizeObserver(target, ([entry]) => {
        width.value = entry.contentRect.width;
        height.value = entry.contentRect.height;
    }, options);
    return {
        width,
        height,
    };
}

/**
 * Tracks the visibility of an element within the viewport.
 *
 * @see   {@link https://vueuse.js.org/useElementVisibility}
 * @param element
 * @param options
 */
function useElementVisibility(element, { window = defaultWindow, scrollTarget } = {}) {
    const elementIsVisible = ref(false);
    const testBounding = () => {
        if (!window)
            return;
        const document = window.document;
        if (!element.value) {
            elementIsVisible.value = false;
        }
        else {
            const rect = element.value.getBoundingClientRect();
            elementIsVisible.value = (rect.top <= (window.innerHeight || document.documentElement.clientHeight)
                && rect.left <= (window.innerWidth || document.documentElement.clientWidth)
                && rect.bottom >= 0
                && rect.right >= 0);
        }
    };
    tryOnMounted(testBounding);
    if (window)
        tryOnMounted(() => useEventListener((scrollTarget === null || scrollTarget === void 0 ? void 0 : scrollTarget.value) || window, 'scroll', testBounding, { capture: false, passive: true }));
    return elementIsVisible;
}

/**
 * Reactive wrapper for EventSource.
 *
 * @see   {@link https://vueuse.js.org/useEventSource}
 * @see   {@link https://developer.mozilla.org/en-US/docs/Web/API/EventSource/EventSource|EventSource}
 * @param url
 * @param events
 */
function useEventSource(url, events = []) {
    const event = ref(null);
    const data = ref(null);
    const status = ref('CONNECTING');
    const eventSource = ref(null);
    const error = ref(null);
    const close = () => {
        if (eventSource.value) {
            eventSource.value.close();
            eventSource.value = null;
            status.value = 'CLOSED';
        }
    };
    tryOnMounted(() => {
        const es = new EventSource(url);
        eventSource.value = es;
        es.onopen = () => {
            status.value = 'OPEN';
            error.value = null;
        };
        es.onerror = (e) => {
            status.value = 'CLOSED';
            error.value = e;
        };
        es.onmessage = (e) => {
            event.value = null;
            data.value = e.data;
        };
        for (const event_name of events) {
            useEventListener(es, event_name, (e) => {
                event.value = event_name;
                data.value = e.data || null;
            });
        }
    });
    tryOnUnmounted(() => {
        close();
    });
    return {
        eventSource,
        event,
        data,
        status,
        error,
        close,
    };
}

/**
 * Reactive favicon.
 *
 * @see   {@link https://vueuse.js.org/useFavicon}
 * @param newIcon
 * @param options
 */
function useFavicon(newIcon = null, options = {}) {
    const { baseUrl = '', rel = 'icon', document = defaultDocument, } = options;
    const favicon = isRef(newIcon)
        ? newIcon
        : ref(newIcon);
    const applyIcon = (icon) => {
        document === null || document === void 0 ? void 0 : document.head.querySelectorAll(`link[rel*="${rel}"]`).forEach(el => el.href = `${baseUrl}${icon}`);
    };
    watch(favicon, (i, o) => {
        if (isString(i) && i !== o)
            applyIcon(i);
    }, { immediate: true });
    return favicon;
}

/* this implementation is original ported from https://github.com/logaretm/vue-use-web by Abdelrahman Awad */
/**
 * Reactive Fullscreen API.
 *
 * @see   {@link https://vueuse.js.org/useFullscreen}
 * @param target
 * @param options
 */
function useFullscreen(target, options = {}) {
    const { document = defaultDocument } = options;
    const targetRef = ref(target || (document === null || document === void 0 ? void 0 : document.querySelector('html')));
    const isFullscreen = ref(false);
    async function exit() {
        if (document === null || document === void 0 ? void 0 : document.fullscreenElement)
            await document.exitFullscreen();
        isFullscreen.value = false;
    }
    async function enter() {
        exit();
        if (targetRef.value) {
            await targetRef.value.requestFullscreen();
            isFullscreen.value = true;
        }
    }
    async function toggle() {
        if (isFullscreen.value)
            await exit();
        else
            await enter();
    }
    return {
        isFullscreen,
        enter,
        exit,
        toggle,
    };
}

/* this implementation is original ported from https://github.com/logaretm/vue-use-web by Abdelrahman Awad */
/**
 * Reactive Geolocation API.
 *
 * @see   {@link https://vueuse.js.org/useGeolocation}
 * @param options
 */
function useGeolocation(options = {}) {
    const { enableHighAccuracy = true, maximumAge = 30000, timeout = 27000, navigator = defaultNavigator, } = options;
    const isSupported = navigator && 'geolocation' in navigator;
    const locatedAt = ref(null);
    const error = ref(null);
    const coords = ref({
        accuracy: 0,
        latitude: 0,
        longitude: 0,
        altitude: null,
        altitudeAccuracy: null,
        heading: null,
        speed: null,
    });
    function updatePosition(position) {
        locatedAt.value = position.timestamp;
        coords.value = position.coords;
        error.value = null;
    }
    let watcher;
    tryOnMounted(() => {
        if (isSupported) {
            watcher = navigator.geolocation.watchPosition(updatePosition, err => error.value = err, {
                enableHighAccuracy,
                maximumAge,
                timeout,
            });
        }
    });
    tryOnUnmounted(() => {
        if (watcher && navigator)
            navigator.geolocation.clearWatch(watcher);
    });
    return {
        isSupported,
        coords,
        locatedAt,
        error,
    };
}

const defaultEvents = ['mousemove', 'mousedown', 'resize', 'keydown', 'touchstart', 'wheel'];
const oneMinute = 60000;
/**
 * Tracks whether the user is being inactive.
 *
 * @see   {@link https://vueuse.js.org/useIdle}
 * @param timeout default to 1 minute
 * @param options IdleOptions
 */
function useIdle(timeout = oneMinute, options = {}) {
    const { initialState = false, listenForVisibilityChange = true, events = defaultEvents, window = defaultWindow, eventFilter = throttleFilter(50), } = options;
    const idle = ref(initialState);
    const lastActive = ref(timestamp());
    let timer;
    const onEvent = createFilterWrapper(eventFilter, () => {
        idle.value = false;
        lastActive.value = timestamp();
        clearTimeout(timer);
        timer = setTimeout(() => idle.value = true, timeout);
    });
    if (window) {
        const document = window.document;
        for (const event of events)
            useEventListener(window, event, onEvent, { passive: true });
        if (listenForVisibilityChange) {
            useEventListener(document, 'visibilitychange', () => {
                if (!document.hidden)
                    onEvent();
            });
        }
    }
    timer = setTimeout(() => idle.value = true, timeout);
    return { idle, lastActive };
}

/**
 * Detects that a target element's visibility.
 *
 * @see   {@link https://vueuse.js.org/useIntersectionObserver}
 * @param target
 * @param callback
 * @param options
 */
function useIntersectionObserver(target, callback, options = {}) {
    const { root, rootMargin = '0px', threshold = 0.1, window = defaultWindow, } = options;
    let observer;
    const targetRef = ref(target);
    const isSupported = window && 'IntersectionObserver' in window;
    const cleanup = () => {
        if (observer) {
            observer.disconnect();
            observer = undefined;
        }
    };
    const stopWatch = watch(targetRef, (newValue) => {
        cleanup();
        if (isSupported && window && newValue) {
            // @ts-expect-error missing type
            observer = new window.IntersectionObserver(callback, {
                root: unref(root),
                rootMargin,
                threshold,
            });
            observer.observe(newValue);
        }
    });
    const stop = () => {
        cleanup();
        stopWatch();
    };
    tryOnUnmounted(stop);
    return {
        isSupported,
        stop,
    };
}

const Serializers = {
    boolean: {
        read: (v, d) => v != null ? v === 'true' : d,
        write: (v) => String(v),
    },
    object: {
        read: (v, d) => v ? JSON.parse(v) : d,
        write: (v) => JSON.stringify(v),
    },
    number: {
        read: (v, d) => v != null ? Number.parseFloat(v) : d,
        write: (v) => String(v),
    },
    any: {
        read: (v, d) => v !== null && v !== void 0 ? v : d,
        write: (v) => String(v),
    },
    string: {
        read: (v, d) => v !== null && v !== void 0 ? v : d,
        write: (v) => String(v),
    },
};
/**
 * Reactive LocalStorage/SessionStorage.
 *
 * @see   {@link https://vueuse.js.org/useStorage}
 * @param key
 * @param defaultValue
 * @param storage
 * @param options
 */
function useStorage(key, defaultValue, storage = defaultWindow === null || defaultWindow === void 0 ? void 0 : defaultWindow.localStorage, options = {}) {
    const { flush = 'pre', deep = true, listenToStorageChanges = true, window = defaultWindow, eventFilter, } = options;
    const data = ref(defaultValue);
    const type = defaultValue == null
        ? 'any'
        : typeof defaultValue === 'boolean'
            ? 'boolean'
            : typeof defaultValue === 'string'
                ? 'string'
                : typeof defaultValue === 'object'
                    ? 'object'
                    : Array.isArray(defaultValue)
                        ? 'object'
                        : !Number.isNaN(defaultValue)
                            ? 'number'
                            : 'any';
    function read() {
        if (!storage)
            return;
        try {
            let rawValue = storage.getItem(key);
            if (rawValue === undefined && defaultValue) {
                rawValue = Serializers[type].write(defaultValue);
                storage.setItem(key, rawValue);
            }
            else {
                data.value = Serializers[type].read(rawValue, defaultValue);
            }
        }
        catch (e) {
            console.warn(e);
        }
    }
    read();
    if (window && listenToStorageChanges)
        useEventListener(window, 'storage', read);
    watchWithFilter(data, () => {
        if (!storage) // SSR
            return;
        try {
            if (data.value == null)
                storage.removeItem(key);
            else
                storage.setItem(key, Serializers[type].write(data.value));
        }
        catch (e) {
            console.warn(e);
        }
    }, {
        flush,
        deep,
        eventFilter,
    });
    return data;
}

/**
 * Reactive LocalStorage.
 *
 * @see   {@link https://vueuse.js.org/useLocalStorage}
 * @param key
 * @param defaultValue
 * @param options
 */
function useLocalStorage(key, defaultValue, options = {}) {
    const { window = defaultWindow } = options;
    return useStorage(key, defaultValue, window === null || window === void 0 ? void 0 : window.localStorage, options);
}

const fnClone = (v) => JSON.parse(JSON.stringify(v));
const fnBypass = (v) => v;
const fnSetSource = (source, value) => source.value = value;
function defaultDump(clone) {
    return (clone ? isFunction(clone) ? clone : fnClone : fnBypass);
}
function defaultParse(clone) {
    return (clone ? isFunction(clone) ? clone : fnClone : fnBypass);
}
/**
 * Track the change history of a ref, also provides undo and redo functionality.
 *
 * @see   {@link https://vueuse.js.org/useManualRefHistory}
 * @param source
 * @param options
 */
function useManualRefHistory(source, options = {}) {
    const { clone = false, dump = defaultDump(clone), parse = defaultParse(clone), setSource = fnSetSource, } = options;
    function _createHistoryRecord() {
        return markRaw({
            snapshot: dump(source.value),
            timestamp: timestamp(),
        });
    }
    const last = ref(_createHistoryRecord());
    const undoStack = ref([]);
    const redoStack = ref([]);
    const _setSource = (record) => {
        setSource(source, parse(record.snapshot));
        last.value = record;
    };
    const commit = () => {
        undoStack.value.unshift(last.value);
        last.value = _createHistoryRecord();
        if (options.capacity && undoStack.value.length > options.capacity)
            undoStack.value.splice(options.capacity, Infinity);
        if (redoStack.value.length)
            redoStack.value.splice(0, redoStack.value.length);
    };
    const clear = () => {
        undoStack.value.splice(0, undoStack.value.length);
        redoStack.value.splice(0, redoStack.value.length);
    };
    const undo = () => {
        const state = undoStack.value.shift();
        if (state) {
            redoStack.value.unshift(last.value);
            _setSource(state);
        }
    };
    const redo = () => {
        const state = redoStack.value.shift();
        if (state) {
            undoStack.value.unshift(last.value);
            _setSource(state);
        }
    };
    const reset = () => {
        _setSource(last.value);
    };
    const history = computed(() => [last.value, ...undoStack.value]);
    const canUndo = computed(() => undoStack.value.length > 0);
    const canRedo = computed(() => redoStack.value.length > 0);
    return {
        source,
        undoStack,
        redoStack,
        last,
        history,
        canUndo,
        canRedo,
        clear,
        commit,
        reset,
        undo,
        redo,
    };
}

/**
 * Reactive mouse position.
 *
 * @see   {@link https://vueuse.js.org/useMouse}
 * @param options
 */
function useMouse(options = {}) {
    const { touch = true, resetOnTouchEnds = false, initialValue = { x: 0, y: 0 }, window = defaultWindow, } = options;
    const x = ref(initialValue.x);
    const y = ref(initialValue.y);
    const sourceType = ref(null);
    const mouseHandler = (event) => {
        x.value = event.pageX;
        y.value = event.pageY;
        sourceType.value = 'mouse';
    };
    const reset = () => {
        x.value = initialValue.x;
        y.value = initialValue.y;
    };
    const touchHandler = (event) => {
        if (event.touches.length > 0) {
            x.value = event.touches[0].clientX;
            y.value = event.touches[0].clientY;
            sourceType.value = 'touch';
        }
    };
    if (window) {
        useEventListener(window, 'mousemove', mouseHandler, { passive: true });
        if (touch) {
            useEventListener(window, 'touchstart', touchHandler, { passive: true });
            useEventListener(window, 'touchmove', touchHandler, { passive: true });
            if (resetOnTouchEnds)
                useEventListener(window, 'touchend', reset, { passive: true });
        }
    }
    return {
        x,
        y,
        sourceType,
    };
}

/**
 * Reactive mouse position related to an element.
 *
 * @see   {@link https://vueuse.js.org/useMouseInElement}
 * @param target
 * @param options
 */
function useMouseInElement(target, options = {}) {
    const { handleOutside = true } = options;
    const { x, y, sourceType } = useMouse(options);
    const targetRef = ref(target || (window === null || window === void 0 ? void 0 : window.document.body));
    const elementX = ref(0);
    const elementY = ref(0);
    const elementPositionX = ref(0);
    const elementPositionY = ref(0);
    const elementHeight = ref(0);
    const elementWidth = ref(0);
    const isOutside = ref(false);
    let stop = () => { };
    if (window) {
        stop = watch([targetRef, x, y], () => {
            const el = targetRef.value;
            if (!el)
                return;
            const { left, top, width, height, } = el.getBoundingClientRect();
            elementPositionX.value = left + window.pageXOffset;
            elementPositionY.value = top + window.pageYOffset;
            elementHeight.value = height;
            elementWidth.value = width;
            const elX = x.value - elementPositionX.value;
            const elY = y.value - elementPositionY.value;
            isOutside.value = elX < 0 || elY < 0 || elX > elementWidth.value || elY > elementHeight.value;
            if (handleOutside || !isOutside.value) {
                elementX.value = elX;
                elementY.value = elY;
            }
        }, { immediate: true });
    }
    return {
        x,
        y,
        sourceType,
        elementX,
        elementY,
        elementPositionX,
        elementPositionY,
        elementHeight,
        elementWidth,
        isOutside,
        stop,
    };
}

/**
 * Reactive mouse position.
 *
 * @see   {@link https://vueuse.js.org/useMousePressed}
 * @param options
 */
function useMousePressed(options = {}) {
    const { touch = true, initialValue = false, window = defaultWindow, } = options;
    const target = ref(options.target);
    const pressed = ref(initialValue);
    const sourceType = ref(null);
    let listeners = [];
    if (window) {
        const cleanup = () => {
            listeners.forEach(f => f());
            listeners = [];
        };
        const onReleased = () => {
            pressed.value = false;
            sourceType.value = null;
        };
        watch(target, () => {
            cleanup();
            const t = target.value || window;
            listeners.push(useEventListener(t, 'mousedown', () => {
                pressed.value = true;
                sourceType.value = 'mouse';
            }, { passive: true }));
            if (touch) {
                listeners.push(useEventListener(t, 'touchstart', () => {
                    pressed.value = true;
                    sourceType.value = 'touch';
                }, { passive: true }));
            }
        }, { immediate: true });
        useEventListener(window, 'mouseleave', onReleased, { passive: true });
        useEventListener(window, 'mouseup', onReleased, { passive: true });
        if (touch) {
            useEventListener(window, 'touchend', onReleased, { passive: true });
            useEventListener(window, 'touchcancel', onReleased, { passive: true });
        }
    }
    return {
        pressed,
        sourceType,
    };
}

/**
 * Watch for changes being made to the DOM tree.
 *
 * @see   {@link https://vueuse.js.org/useMutationObserver}
 * @see   {@link https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver|MutationObserver MDN}
 * @param el
 * @param callback
 * @param options
 */
function useMutationObserver(el, callback, options = {}) {
    const { window = defaultWindow } = options, mutationOptions = __rest(options, ["window"]);
    const elRef = ref(el);
    let observer;
    const isSupported = window && 'IntersectionObserver' in window;
    const cleanup = () => {
        if (observer) {
            observer.disconnect();
            observer = undefined;
        }
    };
    const stopWatch = watch(elRef, (newEl) => {
        cleanup();
        if (isSupported && window && newEl) {
            // @ts-expect-error missing type
            observer = new window.MutationObserver(callback);
            observer.observe(newEl, mutationOptions);
        }
    }, { immediate: true });
    const stop = () => {
        cleanup();
        stopWatch();
    };
    tryOnUnmounted(stop);
    return {
        isSupported,
        stop,
    };
}

/* this implementation is original ported from https://github.com/logaretm/vue-use-web by Abdelrahman Awad */
/**
 * Reactive Network status.
 *
 * @see   {@link https://vueuse.js.org/useNetwork}
 * @param options
 */
function useNetwork(options = {}) {
    const { window = defaultWindow } = options;
    const navigator = window === null || window === void 0 ? void 0 : window.navigator;
    const isSupported = Boolean(navigator && 'connection' in navigator);
    const isOnline = ref(true);
    const saveData = ref(false);
    const offlineAt = ref(undefined);
    const downlink = ref(undefined);
    const downlinkMax = ref(undefined);
    const effectiveType = ref(undefined);
    const type = ref('unknown');
    const connection = isSupported && navigator.connection;
    function updateNetworkInformation() {
        if (!navigator)
            return;
        isOnline.value = navigator.onLine;
        offlineAt.value = isOnline.value ? undefined : Date.now();
        if (connection) {
            downlink.value = connection.downlink;
            downlinkMax.value = connection.downlinkMax;
            effectiveType.value = connection.effectiveType;
            saveData.value = connection.saveData;
            type.value = connection.type;
        }
    }
    if (window) {
        useEventListener(window, 'offline', () => {
            isOnline.value = false;
            offlineAt.value = Date.now();
        });
        useEventListener(window, 'online', () => {
            isOnline.value = true;
        });
    }
    if (connection)
        useEventListener(connection, 'change', updateNetworkInformation, false);
    updateNetworkInformation();
    return {
        isSupported,
        isOnline,
        saveData,
        offlineAt,
        downlink,
        downlinkMax,
        effectiveType,
        type,
    };
}

/**
 * Reactive online state.
 *
 * @see   {@link https://vueuse.js.org/useOnline}
 * @param options
 */
function useOnline(options = {}) {
    const { isOnline } = useNetwork(options);
    return isOnline;
}

/**
 * Reactive state to show whether mouse leaves the page.
 *
 * @see   {@link https://vueuse.js.org/usePageLeave}
 * @param options
 */
function usePageLeave(options = {}) {
    const { window = defaultWindow } = options;
    const isLeft = ref(false);
    const handler = (event) => {
        if (!window)
            return;
        event = event || window.event;
        // @ts-ignore
        const from = event.relatedTarget || event.toElement;
        isLeft.value = !from;
    };
    if (window) {
        useEventListener(window, 'mouseout', handler, { passive: true });
        useEventListener(window.document, 'mouseleave', handler, { passive: true });
        useEventListener(window.document, 'mouseenter', handler, { passive: true });
    }
    return isLeft;
}

/**
 * Create parallax effect easily. It uses `useDeviceOrientation` and fallback to `useMouse`
 * if orientation is not supported.
 *
 * @param target
 * @param options
 */
function useParallax(target, options = {}) {
    const { deviceOrientationTiltAdjust = i => i, deviceOrientationRollAdjust = i => i, mouseTiltAdjust = i => i, mouseRollAdjust = i => i, window, } = options;
    const orientation = reactive(useDeviceOrientation({ window }));
    const { elementX: x, elementY: y, elementWidth: width, elementHeight: height, } = useMouseInElement(target, { handleOutside: false, window });
    const source = computed(() => {
        if (orientation.isSupported
            && ((orientation.alpha != null && orientation.alpha !== 0) || (orientation.gamma != null && orientation.gamma !== 0)))
            return 'deviceOrientation';
        return 'mouse';
    });
    const roll = computed(() => {
        if (source.value === 'deviceOrientation') {
            const value = -orientation.beta / 90;
            return deviceOrientationRollAdjust(value);
        }
        else {
            const value = -(y.value - height.value / 2) / height.value;
            return mouseRollAdjust(value);
        }
    });
    const tilt = computed(() => {
        if (source.value === 'deviceOrientation') {
            const value = orientation.gamma / 90;
            return deviceOrientationTiltAdjust(value);
        }
        else {
            const value = (x.value - width.value / 2) / width.value;
            return mouseTiltAdjust(value);
        }
    });
    return { roll, tilt, source };
}

/**
 * Reactive Permissions API.
 *
 * @see   {@link https://vueuse.js.org/usePermission}
 * @param permissionDesc
 * @param options
 */
function usePermission(permissionDesc, options = {}) {
    const { navigator = defaultNavigator } = options;
    let permissionStatus = null;
    const desc = typeof permissionDesc === 'string'
        ? { name: permissionDesc }
        : permissionDesc;
    const state = ref('');
    const onChange = () => {
        if (permissionStatus)
            state.value = permissionStatus.state;
    };
    if (navigator && 'permissions' in navigator) {
        navigator.permissions
            .query(desc)
            .then((status) => {
            permissionStatus = status;
            useEventListener(permissionStatus, 'change', onChange);
            onChange();
        })
            .catch(noop);
    }
    return state;
}

/**
 * Reactive prefers-color-scheme media query.
 *
 * @see   {@link https://vueuse.js.org/usePreferredColorScheme}
 * @param [options]
 */
function usePreferredColorScheme(options) {
    const isLight = useMediaQuery('(prefers-color-scheme: light)', options);
    const isDark = useMediaQuery('(prefers-color-scheme: dark)', options);
    return computed(() => {
        if (isDark.value)
            return 'dark';
        if (isLight.value)
            return 'light';
        return 'no-preference';
    });
}

/**
 * Reactive dark theme preference.
 *
 * @see   {@link https://vueuse.js.org/usePreferredDark}
 * @param [options]
 */
function usePreferredDark(options) {
    return useMediaQuery('(prefers-color-scheme: dark)', options);
}

/**
 * Reactive Navigator Languages.
 *
 * @see   {@link https://vueuse.js.org/usePreferredLanguages}
 * @param options
 */
function usePreferredLanguages(options = {}) {
    const { window = defaultWindow } = options;
    if (!window)
        return ref('en');
    const navigator = window.navigator;
    const value = ref(navigator.languages);
    useEventListener(window, 'languagechange', () => {
        value.value = navigator.languages;
    });
    return value;
}

/**
 * Call function on every `requestAnimationFrame`. With controls of pausing and resuming.
 *
 * @see   {@link https://vueuse.js.org/useRafFn}
 * @param fn
 * @param options
 */
function useRafFn(fn, options = {}) {
    const { immediate = true, window = defaultWindow, } = options;
    const isActive = ref(false);
    function loop() {
        if (!isActive.value)
            return;
        fn();
        if (window)
            window.requestAnimationFrame(loop);
    }
    function resume() {
        if (!isActive.value) {
            isActive.value = true;
            loop();
        }
    }
    function pause() {
        isActive.value = false;
    }
    if (immediate)
        resume();
    tryOnUnmounted(pause);
    return {
        isActive,
        pause,
        resume,
        stop: pause,
        start: resume,
    };
}

/**
 * Track the change history of a ref, also provides undo and redo functionality.
 *
 * @see   {@link https://vueuse.js.org/useRefHistory}
 * @param source
 * @param options
 */
function useRefHistory(source, options = {}) {
    const { deep = false, flush = 'pre', } = options;
    const setSource = (source, value) => {
        // Support changes that are done after the last history operation
        // examples:
        //   undo, modify
        //   undo, undo, modify
        // If there were already changes in the state, they will be ignored
        // examples:
        //   modify, undo
        //   undo, modify, undo
        ignorePrevAsyncUpdates();
        ignoreUpdates(() => {
            source.value = value;
        });
    };
    const manualHistory = useManualRefHistory(source, Object.assign(Object.assign({}, options), { clone: options.clone || deep, setSource }));
    const { clear, commit: manualCommit } = manualHistory;
    const commit = () => {
        // This guard only applies for flush 'pre' and 'post'
        // If the user triggers a commit manually, then reset the watcher
        // so we do not trigger an extra commit in the async watcher
        ignorePrevAsyncUpdates();
        manualCommit();
    };
    const { eventFilter, pause, resume: resumeTracking, isActive: isTracking } = pausableFilter();
    const { ignoreUpdates, ignorePrevAsyncUpdates, stop } = ignorableWatch(source, commit, { deep, flush, eventFilter });
    const resume = (commitNow) => {
        resumeTracking();
        if (commitNow)
            commit();
    };
    const batch = (fn) => {
        let canceled = false;
        const cancel = () => canceled = true;
        ignoreUpdates(() => {
            fn(cancel);
        });
        if (!canceled)
            commit();
    };
    const dispose = () => {
        stop();
        clear();
    };
    return Object.assign(Object.assign({}, manualHistory), { isTracking,
        pause,
        resume,
        commit,
        batch,
        dispose });
}

/**
 * Reactive SessionStorage.
 *
 * @see   {@link https://vueuse.js.org/useSessionStorage}
 * @param key
 * @param defaultValue
 * @param options
 */
function useSessionStorage(key, defaultValue, options = {}) {
    const { window = defaultWindow } = options;
    return useStorage(key, defaultValue, window === null || window === void 0 ? void 0 : window.sessionStorage, options);
}

/**
 * Reactive Web Share API.
 *
 * @use   {@link https://vueuse.js.org/useShare}
 * @param shareOptions
 * @param options
 */
function useShare(shareOptions = {}, options = {}) {
    const { navigator = defaultNavigator } = options;
    const _navigator = navigator;
    const isSupported = 'canShare' in _navigator;
    const share = async (overrideOptions = {}) => {
        if (isSupported) {
            const data = Object.assign(Object.assign({}, unref(shareOptions)), unref(overrideOptions));
            let granted = true;
            if (data.files && _navigator.canShare)
                granted = _navigator.canShare({ files: data.files });
            if (granted)
                return _navigator.share(data);
        }
    };
    return {
        isSupported,
        share,
    };
}

// ported from https://www.reddit.com/r/vuejs/comments/jksizl/speech_recognition_as_a_vue_3_hook
/**
 * Reactive SpeechRecognition.
 *
 * @see   {@link https://vueuse.js.org/useSpeechRecognition}
 * @see   {@link https://developer.mozilla.org/en-US/docs/Web/API/SpeechRecognition|SpeechRecognition}
 * @param options
 */
function useSpeechRecognition(options = {}) {
    const { lang = 'en-US', interimResults = true, continuous = true, } = options;
    const isListening = ref(false);
    const isFinal = ref(false);
    const result = ref('');
    const error = ref(null);
    const toggle = (value = !isListening.value) => {
        isListening.value = value;
    };
    const start = () => {
        isListening.value = true;
    };
    const stop = () => {
        isListening.value = false;
    };
    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
    const isSupported = Boolean(SpeechRecognition);
    let recognition;
    if (isSupported) {
        recognition = new SpeechRecognition();
        recognition.continuous = continuous;
        recognition.interimResults = interimResults;
        recognition.lang = lang;
        recognition.onstart = () => {
            isFinal.value = false;
        };
        recognition.onresult = (event) => {
            const transcript = Array.from(event.results)
                .map((result) => {
                isFinal.value = result.isFinal;
                return result[0];
            })
                .map(result => result.transcript)
                .join('');
            result.value = transcript;
            error.value = null;
        };
        recognition.onerror = (event) => {
            error.value = event.error;
        };
        recognition.onend = () => {
            isListening.value = false;
        };
        watch(isListening, () => {
            if (isListening.value)
                recognition.start();
            else
                recognition.stop();
        });
    }
    tryOnUnmounted(() => {
        isListening.value = false;
    });
    return {
        isSupported,
        isListening,
        isFinal,
        recognition,
        result,
        error,
        toggle,
        start,
        stop,
    };
}

/**
 * Reactive current timestamp.
 *
 * @see   {@link https://vueuse.js.org/useTimestamp}
 * @param options
 */
function useTimestamp(options = {}) {
    const { offset = 0 } = options;
    const ts = ref(timestamp() + offset);
    const controls = useRafFn(() => ts.value = timestamp() + offset, { immediate: true });
    return Object.assign({ timestamp: ts }, controls);
}

/**
 * Reactive document title.
 *
 * @see   {@link https://vueuse.js.org/useTitle}
 * @param newTitle
 * @param options
 */
function useTitle(newTitle = null, { document = defaultDocument } = {}) {
    var _a;
    const title = ref((_a = newTitle !== null && newTitle !== void 0 ? newTitle : document === null || document === void 0 ? void 0 : document.title) !== null && _a !== void 0 ? _a : null);
    watch(title, (t, o) => {
        if (isString(t) && t !== o && document)
            document.title = t;
    }, { immediate: true });
    return title;
}

/**
 * Create an easing function from cubic bezier points.
 */
function createEasingFunction([p0, p1, p2, p3]) {
    const a = (a1, a2) => 1 - 3 * a2 + 3 * a1;
    const b = (a1, a2) => 3 * a2 - 6 * a1;
    const c = (a1) => 3 * a1;
    const calcBezier = (t, a1, a2) => ((a(a1, a2) * t + b(a1, a2)) * t + c(a1)) * t;
    const getSlope = (t, a1, a2) => 3 * a(a1, a2) * t * t + 2 * b(a1, a2) * t + c(a1);
    const getTforX = (x) => {
        let aGuessT = x;
        for (let i = 0; i < 4; ++i) {
            const currentSlope = getSlope(aGuessT, p0, p2);
            if (currentSlope === 0)
                return aGuessT;
            const currentX = calcBezier(aGuessT, p0, p2) - x;
            aGuessT -= currentX / currentSlope;
        }
        return aGuessT;
    };
    return (x) => p0 === p1 && p2 === p3 ? x : calcBezier(getTforX(x), p1, p3);
}
/**
 * Common transitions
 *
 * @see   {@link https://easings.net}
 */
const TransitionPresets = {
    linear: [0, 0, 1, 1],
    easeInSine: [0.12, 0, 0.39, 0],
    easeOutSine: [0.61, 1, 0.88, 1],
    easeInQuad: [0.11, 0, 0.5, 0],
    easeOutQuad: [0.5, 1, 0.89, 1],
    easeInCubic: [0.32, 0, 0.67, 0],
    easeOutCubic: [0.33, 1, 0.68, 1],
    easeInOutCubic: [0.65, 0, 0.35, 1],
    easeInQuart: [0.5, 0, 0.75, 0],
    easeOutQuart: [0.25, 1, 0.5, 1],
    easeInOutQuart: [0.76, 0, 0.24, 1],
    easeInQuint: [0.64, 0, 0.78, 0],
    easeOutQuint: [0.22, 1, 0.36, 1],
    easeInOutQuint: [0.83, 0, 0.17, 1],
    easeInExpo: [0.7, 0, 0.84, 0],
    easeOutExpo: [0.16, 1, 0.3, 1],
    easeInOutExpo: [0.87, 0, 0.13, 1],
    easeInCirc: [0.55, 0, 1, 0.45],
    easeOutCirc: [0, 0.55, 0.45, 1],
    easeInOutCirc: [0.85, 0, 0.15, 1],
    easeInBack: [0.36, 0, 0.66, -0.56],
    easeOutBack: [0.34, 1.56, 0.64, 1],
    easeInOutBack: [0.68, -0.6, 0.32, 1.6],
};
/**
 * Transition between values.
 *
 * @see   {@link https://vueuse.js.org/useTransition}
 * @param source
 * @param options
 */
function useTransition(source, options = {}) {
    const { duration = 500, transition = (n) => n, } = options;
    const output = ref(source.value);
    const getValue = isFunction(transition)
        ? transition
        : createEasingFunction(transition);
    let diff = 0;
    let endAt = 0;
    let startAt = 0;
    let startValue = 0;
    const { resume, pause } = useRafFn(() => {
        const now = Date.now();
        const progress = clamp(1 - ((endAt - now) / duration), 0, 1);
        output.value = startValue + (diff * getValue(progress));
        if (progress >= 1)
            pause();
    }, { immediate: false });
    watch(source, () => {
        pause();
        diff = source.value - output.value;
        startValue = output.value;
        startAt = Date.now();
        endAt = startAt + duration;
        resume();
    });
    return output;
}

/**
 * Shorthand for v-model binding, props + emit -> ref
 *
 * @see   {@link https://vueuse.js.org/useVModel}
 * @param props
 * @param key
 * @param emit
 */
function useVModel(props, key, emit) {
    var _a;
    const vueCurrentInstance = getCurrentInstance();
    // @ts-expect-error mis-alignment with @vue/composition-api
    const _emit = emit || isVue3 ? vueCurrentInstance === null || vueCurrentInstance === void 0 ? void 0 : vueCurrentInstance.emit : (_a = vueCurrentInstance === null || vueCurrentInstance === void 0 ? void 0 : vueCurrentInstance.$emit) === null || _a === void 0 ? void 0 : _a.bind(vueCurrentInstance);
    return computed({
        get() {
            return props[key];
        },
        set(value) {
            _emit(`update:${key}`, value);
        },
    });
}

/* this implementation is original ported from https://github.com/logaretm/vue-use-web by Abdelrahman Awad */
/**
 * Reactive simple WebSocket client.
 *
 * @see   {@link https://vueuse.js.org/useWebSocket}
 * @param url
 */
function useWebSocket(url) {
    const data = ref(null);
    const state = ref('CONNECTING');
    let ws;
    const close = function close(code, reason) {
        if (!ws)
            return;
        ws.close(code, reason);
    };
    const send = function send(data) {
        if (!ws)
            return;
        ws.send(data);
    };
    ws = new WebSocket(url);
    ws.onopen = () => {
        state.value = 'OPEN';
    };
    ws.onclose = ws.onerror = () => {
        state.value = 'CLOSED';
    };
    ws.onmessage = (e) => {
        data.value = e.data;
    };
    tryOnUnmounted(() => {
        ws.close();
    });
    return {
        data,
        state,
        close,
        send,
        ws,
    };
}

/* this implementation is original ported from https://github.com/logaretm/vue-use-web by Abdelrahman Awad */
/**
 * Simple Web Workers registration and communication.
 *
 * @see   {@link https://vueuse.js.org/useWebWorker}
 * @param url
 */
function useWebWorker(url) {
    const data = ref(null);
    let worker;
    const post = function post(val) {
        if (!worker)
            return;
        worker.postMessage(val);
    };
    const terminate = function terminate() {
        if (!worker)
            return;
        worker.terminate();
    };
    worker = new Worker(url);
    worker.onmessage = (e) => {
        data.value = e.data;
    };
    tryOnUnmounted(() => {
        worker.terminate();
    });
    return {
        data,
        post,
        terminate,
    };
}

/**
 * This function accepts as a parameter a function "userFunc"
 * And as a result returns an anonymous function.
 * This anonymous function, accepts as arguments,
 * the parameters to pass to the function "useArgs" and returns a Promise
 * This function can be used as a wrapper, only inside a Worker
 * because it depends by "postMessage".
 *
 * @param {Function} userFunc {Function} fn the function to run with web worker
 *
 * @returns {Function} returns a function that accepts the parameters
 * to be passed to the "userFunc" function
 */
const jobRunner = (userFunc) => (e) => {
    const userFuncArgs = e.data[0];
    // eslint-disable-next-line prefer-spread
    return Promise.resolve(userFunc.apply(undefined, userFuncArgs))
        .then((result) => {
        // @ts-ignore
        postMessage(['SUCCESS', result]);
    })
        .catch((error) => {
        // @ts-ignore
        postMessage(['ERROR', error]);
    });
};

/**
 *
 * Concatenates the dependencies into a comma separated string.
 * this string will then be passed as an argument to the "importScripts" function
 *
 * @param {Array.<String>}} deps array of string
 * @returns {String} a string composed by the concatenation of the array
 * elements "deps" and "importScripts".
 *
 * @example
 * depsParser(['demo1', 'demo2']) // return importScripts('demo1, demo2')
 */
const depsParser = (deps) => {
    if (deps.length === 0)
        return '';
    const depsString = deps.map(dep => `${dep}`).toString();
    return `importScripts('${depsString}')`;
};

/**
 * Converts the "fn" function into the syntax needed to be executed within a web worker
 *
 * @param {Function} fn the function to run with web worker
 * @param {Array.<String>} deps array of strings, imported into the worker through "importScripts"
 *
 * @returns {String} a blob url, containing the code of "fn" as a string
 *
 * @example
 * createWorkerBlobUrl((a,b) => a+b, [])
 * // return "onmessage=return Promise.resolve((a,b) => a + b)
 * .then(postMessage(['SUCCESS', result]))
 * .catch(postMessage(['ERROR', error])"
 */
const createWorkerBlobUrl = (fn, deps) => {
    const blobCode = `${depsParser(deps)}; onmessage=(${jobRunner})(${fn})`;
    const blob = new Blob([blobCode], { type: 'text/javascript' });
    const url = URL.createObjectURL(blob);
    return url;
};

/* this implementation is a vue port of https://github.com/alewin/useWorker by Alessio Koci */
/**
 * Run expensive function without blocking the UI, using a simple syntax that makes use of Promise.
 *
 * @see   {@link https://vueuse.js.org/useWebWorkerFn}
 * @param fn
 * @param options
 */
const useWebWorkerFn = (fn, { dependencies = [], timeout, window = defaultWindow, } = {}) => {
    const worker = ref(undefined);
    const workerStatus = ref('PENDING');
    const promise = ref({});
    const timeoutId = ref(undefined);
    const workerTerminate = (status = 'PENDING') => {
        if (worker.value && worker.value._url && window) {
            worker.value.terminate();
            URL.revokeObjectURL(worker.value._url);
            promise.value = {};
            worker.value = undefined;
            window.clearTimeout(timeoutId.value);
            workerStatus.value = status;
        }
    };
    workerTerminate();
    tryOnUnmounted(() => {
        workerTerminate();
    });
    const generateWorker = () => {
        const blobUrl = createWorkerBlobUrl(fn, dependencies);
        const newWorker = new Worker(blobUrl);
        newWorker._url = blobUrl;
        newWorker.onmessage = (e) => {
            const { resolve = () => { }, reject = () => { }, } = promise.value;
            const [status, result] = e.data;
            switch (status) {
                case 'SUCCESS':
                    resolve(result);
                    workerTerminate(status);
                    break;
                default:
                    reject(result);
                    workerTerminate('ERROR');
                    break;
            }
        };
        newWorker.onerror = (e) => {
            const { reject = () => { }, } = promise.value;
            reject(e);
            workerTerminate('ERROR');
        };
        if (timeout) {
            timeoutId.value = setTimeout(() => workerTerminate('TIMEOUT_EXPIRED'), timeout);
        }
        return newWorker;
    };
    const callWorker = (...fnArgs) => new Promise((resolve, reject) => {
        promise.value = {
            resolve,
            reject,
        };
        worker.value && worker.value.postMessage([[...fnArgs]]);
        workerStatus.value = 'RUNNING';
    });
    const workerFn = (...fnArgs) => {
        if (workerStatus.value === 'RUNNING') {
            /* eslint-disable-next-line no-console */
            console.error('[useWebWorkerFn] You can only run one instance of the worker at a time.');
            /* eslint-disable-next-line prefer-promise-reject-errors */
            return Promise.reject();
        }
        worker.value = generateWorker();
        return callWorker(...fnArgs);
    };
    return {
        workerFn,
        workerStatus,
        workerTerminate,
    };
};

/**
 * Reactive window scroll.
 *
 * @see   {@link https://vueuse.js.org/useWindowScroll}
 * @param options
 */
function useWindowScroll({ window = defaultWindow } = {}) {
    if (!window) {
        return {
            x: ref(0),
            y: ref(0),
        };
    }
    const x = ref(window.pageXOffset);
    const y = ref(window.pageYOffset);
    useEventListener('scroll', () => {
        x.value = window.pageXOffset;
        y.value = window.pageYOffset;
    }, {
        capture: false,
        passive: true,
    });
    return { x, y };
}

/**
 * Reactive window size.
 *
 * @see   {@link https://vueuse.js.org/useWindowSize}
 * @param options
 */
function useWindowSize({ window = defaultWindow, initialWidth = Infinity, initialHeight = Infinity } = {}) {
    if (!window) {
        return {
            width: ref(initialWidth),
            height: ref(initialHeight),
        };
    }
    const width = ref(window.innerWidth);
    const height = ref(window.innerHeight);
    useEventListener('resize', () => {
        width.value = window.innerWidth;
        height.value = window.innerHeight;
    }, { passive: true });
    return { width, height };
}

export { TransitionPresets, asyncComputed, createGlobalState, onClickOutside, onStartTyping, useAsyncState, useBattery, useBrowserLocation, useClipboard, useCssVar, useDeviceLight, useDeviceMotion, useDeviceOrientation, useDevicePixelRatio, useDocumentVisibility, useElementBounding, useElementSize, useElementVisibility, useEventListener, useEventSource, useFavicon, useFullscreen, useGeolocation, useIdle, useIntersectionObserver, useLocalStorage, useManualRefHistory, useMediaQuery, useMouse, useMouseInElement, useMousePressed, useMutationObserver, useNetwork, useOnline, usePageLeave, useParallax, usePermission, usePreferredColorScheme, usePreferredDark, usePreferredLanguages, useRafFn, useRefHistory, useResizeObserver, useSessionStorage, useShare, useSpeechRecognition, useStorage, useTimestamp, useTitle, useTransition, useVModel, useWebSocket, useWebWorker, useWebWorkerFn, useWindowScroll, useWindowSize };
