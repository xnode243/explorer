{"ast":null,"code":"//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\nimport { BSkeleton, BSkeletonWrapper, BInputGroupAppend, BTabs, BTab, BFormGroup, BFormSelect, BFormSelectOption, BRow, BCol, VBTooltip, BFormInput, BCard, BAlert, BFormCheckbox, BButton, BBadge, BInputGroup, BInputGroupPrepend } from 'bootstrap-vue';\nimport { consensusPubkeyToHexAddress, getCachedValidators, timeIn, toDay } from '@/libs/utils';\nimport { fromBech32, fromHex, toBase64 } from '@cosmjs/encoding';\nexport default {\n  components: {\n    BRow,\n    BCol,\n    BFormInput,\n    BFormGroup,\n    BCard,\n    BAlert,\n    BButton,\n    BBadge,\n    BFormCheckbox,\n    BFormSelect,\n    BFormSelectOption,\n    BInputGroup,\n    BSkeleton,\n    BSkeletonWrapper,\n    BInputGroupPrepend,\n    BInputGroupAppend,\n    BTabs,\n    BTab\n  },\n  directives: {\n    'b-tooltip': VBTooltip\n  },\n\n  data() {\n    const {\n      chain\n    } = this.$route.params;\n    const pinned = localStorage.getItem('pinned') ? localStorage.getItem('pinned').split(',') : '';\n    return {\n      height: 0,\n      loading: true,\n      missedFilter: false,\n      pinned,\n      chain,\n      query: '',\n      validators: [],\n      missing: {},\n      blocks: Array.from('0'.repeat(50)).map(x => ({\n        sigs: {},\n        height: Number(x)\n      })),\n      syncing: false,\n      latestTime: '',\n      threshold: 10,\n      proposers: {},\n      absentValsInBlock: {},\n      numOfBlock: 1000,\n      temp: 0,\n      frequency: 6000\n    };\n  },\n\n  computed: {\n    uptime() {\n      const vals = this.query ? this.validators.filter(x => String(x.description.moniker).indexOf(this.query) > -1) : this.validators;\n      vals.sort((a, b) => b.delegator_shares - a.delegator_shares);\n      const rets = vals.map(x => ({\n        validator: x.description,\n        address: this.hex2base64(consensusPubkeyToHexAddress(x.consensus_pubkey))\n      }));\n\n      if (this.missedFilter) {\n        return rets.filter(x => this.missing[x.address].missed_blocks_counter > 0);\n      }\n\n      return rets;\n    },\n\n    // Compose data for group by proposer\n    proposerViewData() {\n      const valCounter = {};\n      this.validators.forEach(x => {\n        valCounter[this.hex2base64(consensusPubkeyToHexAddress(x.consensus_pubkey))] = {\n          name: x.description.moniker,\n          counter: 0,\n          proposed: 0\n        };\n      });\n      Object.keys(this.proposers).forEach(height => {\n        const num = this.absentValsInBlock[height] || 0;\n\n        if (valCounter[this.proposers[height]]) {\n          if (num > this.threshold) {\n            valCounter[this.proposers[height]].counter += 1; // (num >= Number(this.threshold) ? 1 : 0)\n          }\n\n          valCounter[this.proposers[height]].proposed += 1;\n        }\n      });\n      return Object.values(valCounter).sort((a, b) => b.counter - a.counter);\n    },\n\n    h() {\n      return this.height;\n    }\n\n  },\n\n  created() {\n    const cached = JSON.parse(getCachedValidators(this.$route.params.chain));\n\n    if (cached) {\n      this.validators = cached;\n    }\n\n    this.fetchMissingInfo();\n    this.$http.getValidatorList().then(res => {\n      this.validators = res;\n    });\n    this.initBlocks();\n  },\n\n  beforeDestroy() {\n    this.blocks = []; // clear running tasks if it is not finish\n\n    this.syncing = false;\n    clearInterval(this.timer);\n  },\n\n  methods: {\n    fetchMissingInfo() {\n      this.$http.getSlashingSigningInfo().then(res => {\n        if (res.info) {\n          res.info.forEach(x => {\n            if (x.address) {\n              const hex = toBase64(fromBech32(x.address).data);\n              this.missing[hex] = x;\n            }\n          });\n        }\n      });\n    },\n\n    pinValidator() {\n      localStorage.setItem('pinned', this.pinned);\n    },\n\n    initBlocks() {\n      this.$http.getLatestBlock().then(d => {\n        const {\n          height\n        } = d.block.last_commit;\n\n        if (timeIn(d.block.header.time, 3, 'm')) {\n          this.syncing = true;\n        } else {\n          this.syncing = false;\n        }\n\n        this.latestTime = toDay(d.block.header.time, 'long');\n        const blocks = []; // update height\n\n        let promise = Promise.resolve();\n\n        for (let i = height - 1; i > height - 48; i -= 1) {\n          blocks.unshift({\n            sigs: {},\n            height: i > 0 ? i : 0\n          });\n          promise = promise.then(() => new Promise(resolve => {\n            if (i > this.blocks[0].height && i > 0) {\n              // filter useless loading\n              this.fetch_status(i, resolve);\n            } else {\n              resolve();\n            }\n          }));\n        }\n\n        const sigs = this.initColor();\n        d.block.last_commit.signatures.forEach(x => {\n          if (x.validator_address) sigs[x.validator_address] = 'bg-success';\n        });\n        blocks.push({\n          sigs,\n          height\n        });\n        this.blocks = blocks;\n        this.timer = setInterval(this.fetch_latest, this.frequency);\n        this.loading = false;\n      });\n    },\n\n    initColor() {\n      const sigs = {};\n      this.validators.forEach(x => {\n        sigs[this.hex2base64(consensusPubkeyToHexAddress(x.consensus_pubkey))] = 'bg-danger';\n      });\n      return sigs;\n    },\n\n    onFrequencyChange() {\n      clearInterval(this.timer);\n      this.timer = setInterval(this.fetch_latest, this.frequency);\n    },\n\n    hex2base64(v) {\n      return toBase64(fromHex(v));\n    },\n\n    fetch_status(height, resolve) {\n      this.$http.getBlockByHeight(height).then(res => {\n        resolve();\n        const block = this.blocks.find(b => b.height === height); // update valiators states\n\n        if (block) {\n          const sigs = this.initColor();\n          res.block.last_commit.signatures.forEach(x => {\n            if (x.validator_address) sigs[x.validator_address] = 'bg-success';\n          });\n          this.$set(block, 'sigs', sigs);\n        } // update proposer states\n\n\n        this.count(res.block);\n      });\n    },\n\n    /// count how many absent valiators in a block\n    count(block) {\n      const count = block.last_commit.signatures.reduce((p, c) => c.block_id_flag !== 'BLOCK_ID_FLAG_COMMIT' ? p + 1 : p, 0); // Notes: block.header.height == last_commint.height + 1\n\n      this.$set(this.proposers, block.header.height, block.header.proposer_address);\n      this.$set(this.absentValsInBlock, block.last_commit.height, count);\n\n      if (count >= this.threshold) {\n        this.temp += 1;\n      }\n    },\n\n    fetch_latest() {\n      this.$http.getLatestBlock().then(res => {\n        const sigs = this.initColor();\n        res.block.last_commit.signatures.forEach(x => {\n          if (x.validator_address) sigs[x.validator_address] = 'bg-success';\n        });\n        this.height = Number(res.block.header.height);\n\n        if (this.height % 100 === 0) {\n          // update the missing number each 100\n          this.fetchMissingInfo();\n        }\n\n        const block = this.blocks.find(b => b.height === res.block.last_commit.height);\n\n        if (typeof block === 'undefined') {\n          // mei\n          // this.$set(block, 0, typeof sigs !== 'undefined')\n          if (this.blocks.length >= 50) this.blocks.shift();\n          this.blocks.push({\n            sigs,\n            height: res.block.last_commit.height\n          });\n        }\n\n        this.count(res.block);\n      });\n    }\n\n  }\n};","map":null,"metadata":{},"sourceType":"module"}