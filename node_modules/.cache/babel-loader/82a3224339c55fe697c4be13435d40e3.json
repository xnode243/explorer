{"ast":null,"code":"//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\n/* eslint-disable */\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nconst long_1 = __importDefault(require(\"long\"));\n\nimport { BFormInput, BButton, BAlert, BFormGroup, BInputGroup, BInputGroupAppend, BFormRadio, BFormRadioGroup, BCard, BPopover } from 'bootstrap-vue';\nimport FeatherIcon from '@core/components/feather-icon/FeatherIcon.vue';\nimport { formatTokenAmount, getLocalAccounts, percent, setLocalTxHistory, sign } from '@/libs/utils';\nimport { getPairName } from '@/libs/osmos';\nimport ToastificationContent from '@core/components/toastification/ToastificationContent.vue';\nimport DepositeWindow from './DepositeWindow.vue';\nexport default {\n  components: {\n    BAlert,\n    BButton,\n    BCard,\n    BFormInput,\n    BFormRadio,\n    BFormRadioGroup,\n    BFormGroup,\n    BPopover,\n    BInputGroup,\n    BInputGroupAppend,\n    FeatherIcon,\n    DepositeWindow,\n    // eslint-disable-next-line vue/no-unused-components\n    ToastificationContent\n  },\n  props: {\n    type: {\n      type: Number,\n      required: true\n    },\n    pool: {\n      type: Object,\n      default: () => {}\n    },\n    denomTrace: {\n      type: [Array, Object],\n      default: () => []\n    }\n  },\n\n  data() {\n    return {\n      address: '',\n      amount: '',\n      total: '',\n      slippage: 0.05,\n      marks: [0, 0.01, 0.025, 0.05],\n      balance: {},\n      error: null,\n      chainId: 'osmosis-1',\n      wallet: 'keplr',\n      // base: '',\n      // target: '',\n      dismissSecs: 15,\n      dismissCountDown: 0\n    };\n  },\n\n  computed: {\n    base() {\n      return getPairName(this.pool, this.denomTrace, 'base');\n    },\n\n    target() {\n      return getPairName(this.pool, this.denomTrace, 'target');\n    },\n\n    price() {\n      const p1 = this.$store.state.chains.quotes[this.base];\n      const p2 = this.$store.state.chains.quotes[this.target];\n      return p1 && p2 ? (p1.usd / p2.usd).toFixed(4) : '-';\n    },\n\n    localPrice() {\n      const p1 = this.$store.state.chains.quotes[this.target];\n      return p1 && this.total > 0 ? (p1.usd * this.total).toFixed(2) : '-';\n    },\n\n    currentDenom() {\n      if (this.pool && this.pool.poolAssets) {\n        const mode = this.type === 1 ? 0 : 1;\n        const {\n          denom\n        } = this.pool.poolAssets[mode].token;\n        return denom;\n      }\n\n      return '';\n    },\n\n    available() {\n      if (this.pool && this.pool.poolAssets) {\n        let amount = 0;\n\n        if (Array.isArray(this.balance)) {\n          this.balance.forEach(x => {\n            if (x.denom === this.currentDenom) {\n              amount = x.amount;\n            }\n          });\n        }\n\n        return formatTokenAmount(amount, 6, this.currentDenom);\n      }\n\n      return 0;\n    },\n\n    fee() {\n      return percent(this.pool?.poolParams?.swapFee || '');\n    }\n\n  },\n\n  created() {\n    this.initialAddress();\n    this.$http.getBankBalances(this.address).then(res => {\n      if (res && res.length > 0) {\n        this.balance = res;\n      }\n    });\n    this.$http.getAuthAccount(this.address, this.selectedChain).then(ret => {\n      if (ret.value.base_vesting_account) {\n        this.accountNumber = ret.value.base_vesting_account.base_account.account_number;\n        this.sequence = ret.value.base_vesting_account.base_account.sequence;\n        if (!this.sequence) this.sequence = 0;\n      } else {\n        this.accountNumber = ret.value.account_number;\n        this.sequence = ret.value.sequence ? ret.value.sequence : 0;\n      }\n    });\n  },\n\n  methods: {\n    initialAddress() {\n      const {\n        chain\n      } = this.$route.params;\n      const accounts = getLocalAccounts();\n      const current = this.$store.state.chains.defaultWallet;\n\n      if (accounts && accounts[current]) {\n        const acc = accounts[current].address.find(x => x.chain === chain);\n\n        if (acc) {\n          this.address = acc.addr;\n        }\n      }\n    },\n\n    formatAvailable() {},\n\n    changeAmount() {\n      this.total = parseFloat((this.amount * this.price).toFixed(6));\n    },\n\n    changeTotal() {\n      this.amount = parseFloat((this.total / this.price).toFixed(6));\n    },\n\n    async sendTx() {\n      const tokenOutDenom = this.pool.poolAssets[this.type === 0 ? 0 : 1].token.denom;\n      const {\n        denom\n      } = this.pool.poolAssets[this.type === 0 ? 1 : 0].token;\n      const txMsgs = [{\n        typeUrl: '/osmosis.gamm.v1beta1.MsgSwapExactAmountIn',\n        value: {\n          sender: this.address,\n          routes: [{\n            poolId: long_1.default.fromString(this.pool.id),\n            tokenOutDenom\n          }],\n          tokenIn: {\n            denom,\n            amount: long_1.default.fromNumber(parseInt(this.amount * 1000000, 10))\n          },\n          tokenOutMinAmount: long_1.default.fromNumber(parseInt(this.total * 1000000, 10))\n        }\n      }];\n\n      if (txMsgs.length === 0) {\n        this.error = 'No delegation found';\n        this.dismissCountDown = this.dismissSecs;\n        return '';\n      }\n\n      if (!this.accountNumber) {\n        this.error = 'Account number should not be empty!';\n        this.dismissCountDown = this.dismissSecs;\n        return '';\n      }\n\n      const txFee = {\n        amount: [{\n          amount: '800',\n          // this.fee,\n          denom: 'uomos' // this.feeDenom,\n\n        }],\n        gas: '200000' // this.gas,\n\n      };\n      const signerData = {\n        accountNumber: this.accountNumber,\n        sequence: this.sequence,\n        chainId: this.chainId\n      };\n      sign(this.wallet, this.chainId, this.address, txMsgs, txFee, 'Sent Via https://explorer.xnode243.xyz', signerData).then(bodyBytes => {\n        this.$http.broadcastTx(bodyBytes).then(res => {\n          setLocalTxHistory({\n            op: 'swap',\n            hash: res.tx_response.txhash,\n            time: new Date()\n          });\n          this.$toast({\n            component: ToastificationContent,\n            props: {\n              title: 'Transaction sent!',\n              icon: 'EditIcon',\n              variant: 'success'\n            }\n          });\n        }).catch(e => {\n          this.error = e;\n        });\n      }).catch(e => {\n        this.error = e;\n        this.dismissCountDown = this.dismissSecs;\n      }); // Send tokens\n      // return client.sendTokens(this.address, this.recipient, sendCoins, this.memo)\n\n      return '';\n    },\n\n    countDownChanged(dismissCountDown) {\n      this.dismissCountDown = dismissCountDown;\n    }\n\n  }\n};","map":null,"metadata":{},"sourceType":"module"}