{"ast":null,"code":"//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\nimport { BTable, BCard, BCardHeader, BCardTitle, VBTooltip, BTab, BTabs } from 'bootstrap-vue';\nimport { getCachedValidators, getStakingValidatorByHex, toDay, abbr, abbrMessage, tokenFormatter } from '@/libs/utils';\nimport { decodeTxRaw } from '@cosmjs/proto-signing';\nimport { fromBase64 } from '@cosmjs/encoding';\nimport Tx from '@/libs/data/tx'; // import fetch from 'node-fetch'\n\nexport default {\n  components: {\n    BTab,\n    BTabs,\n    BCard,\n    BTable,\n    BCardHeader,\n    BCardTitle\n  },\n  directives: {\n    'b-tooltip': VBTooltip\n  },\n\n  data() {\n    return {\n      islive: true,\n      blocks: [],\n      txs: [],\n      list_fields: [{\n        key: 'height',\n        sortable: true\n      }, {\n        key: 'hash',\n        thClass: 'd-none d-lg-block',\n        tdClass: 'd-none d-lg-block text-truncate'\n      }, {\n        key: 'proposer',\n        tdClass: 'text-truncate'\n      }, {\n        key: 'txs'\n      }, {\n        key: 'time',\n        thClass: 'd-none d-md-block',\n        tdClass: 'd-none d-md-block'\n      }],\n      txFields: [{\n        key: 'hash'\n      }, {\n        key: 'time',\n        formatter: v => toDay(v, 'from')\n      }, {\n        key: 'fee',\n        formatter: v => tokenFormatter(v)\n      }, {\n        key: 'messages',\n        formatter: v => abbrMessage(v)\n      }, {\n        key: 'memo'\n      }]\n    };\n  },\n\n  created() {\n    this.$http.getLatestBlock().then(res => {\n      this.blocks.push(res);\n      const list = [];\n      const {\n        height\n      } = res.block.header;\n\n      for (let i = 1; i < 10; i += 1) {\n        list.push(height - i);\n      }\n\n      if (!getCachedValidators()) {\n        this.$http.getValidatorList();\n      }\n\n      let promise = Promise.resolve();\n      list.forEach(item => {\n        promise = promise.then(() => new Promise(resolve => {\n          this.$http.getBlockByHeight(item).then(b => {\n            resolve();\n            this.blocks.push(b);\n\n            if (this.txs.length < 20) {\n              this.extractTx(b, 'tail');\n            }\n          });\n        }));\n      });\n      this.timer = setInterval(this.fetch, 6000);\n    });\n  },\n\n  beforeDestroy() {\n    this.islive = false;\n    clearInterval(this.timer);\n  },\n\n  methods: {\n    length: v => Array.isArray(v) ? v.length : 0,\n    shortHash: v => abbr(v),\n    formatTime: v => toDay(v, 'from'),\n\n    formatProposer(v) {\n      return getStakingValidatorByHex(this.$http.config.chain_name, v);\n    },\n\n    fetch() {\n      this.$http.getLatestBlock().then(b => {\n        const has = this.blocks.findIndex(x => x.block.header.height === b.block.header.height);\n\n        if (has < 0) {\n          this.blocks.unshift(b);\n          this.extractTx(b);\n        }\n\n        if (this.blocks.length > 200) this.blocks.pop();\n      });\n    },\n\n    extractTx(block, direction = 'head') {\n      const {\n        txs\n      } = block.block.data;\n      if (txs === null) return;\n\n      for (let i = 0; i < txs.length; i += 1) {\n        let tx = new Tx();\n\n        try {\n          const origin = decodeTxRaw(fromBase64(txs[i]));\n          tx = Tx.create(origin);\n          tx.time = block.block.header.time;\n        } catch (e) {// catch errors\n        }\n\n        tx.setHash(txs[i]);\n\n        if (direction === 'head') {\n          this.txs.unshift(tx);\n\n          if (this.txs.length > 200) {\n            this.txs.pop();\n          }\n        } else if (this.txs.length < 100) {\n          this.txs.push(tx);\n        }\n      }\n    }\n\n  }\n};","map":null,"metadata":{},"sourceType":"module"}