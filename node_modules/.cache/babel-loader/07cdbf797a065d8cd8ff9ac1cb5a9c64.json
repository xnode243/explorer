{"ast":null,"code":"//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\nimport { ValidationProvider, ValidationObserver } from 'vee-validate';\nimport { BAvatar, BModal, BRow, BCol, BInputGroup, BFormInput, BFormGroup, BFormSelect, BFormSelectOption, BForm, BButton, BInputGroupAppend, BFormCheckbox, BOverlay, BAlert } from 'bootstrap-vue';\nimport Ripple from 'vue-ripple-directive';\nimport { required, email, url, between, alpha, integer, password, min, digits, alphaDash, length } from '@validations';\nimport { extractAccountNumberAndSequence, getLocalAccounts, setLocalTxHistory, sign, timeIn } from '@/libs/utils';\nimport vSelect from 'vue-select';\nimport ToastificationContent from '@core/components/toastification/ToastificationContent.vue';\nimport WalletInputVue from './WalletInput.vue';\nimport Delegate from './components/Delegate.vue';\nimport Redelegate from './components/Redelegate.vue';\nimport Withdraw from './components/Withdraw.vue';\nimport Unbond from './components/Unbond.vue';\nimport Transfer from './components/Transfer.vue';\nimport IBCTransfer from './components/IBCTransfer.vue';\nimport Vote from './components/Vote.vue';\nimport WithdrawCommission from './components/WithdrawCommission.vue';\nimport GovDeposit from './components/GovDeposit.vue';\nimport TransactionResult from './TransactionResult.vue';\nexport default {\n  name: 'DelegateDialogue',\n  components: {\n    BAlert,\n    BAvatar,\n    BModal,\n    BRow,\n    BCol,\n    BForm,\n    BInputGroup,\n    BFormInput,\n    BFormGroup,\n    BFormSelect,\n    BFormSelectOption,\n    BFormCheckbox,\n    vSelect,\n    BButton,\n    BInputGroupAppend,\n    BOverlay,\n    WalletInputVue,\n    ValidationProvider,\n    ValidationObserver,\n    // eslint-disable-next-line vue/no-unused-components\n    ToastificationContent,\n    Delegate,\n    Redelegate,\n    Withdraw,\n    Unbond,\n    Transfer,\n    IBCTransfer,\n    Vote,\n    WithdrawCommission,\n    GovDeposit,\n    TransactionResult\n  },\n  directives: {\n    Ripple\n  },\n  props: {\n    type: {\n      type: String,\n      default: ''\n    },\n    modalId: {\n      type: String,\n      default: 'operation-modal'\n    },\n    validatorAddress: {\n      type: String,\n      default: null\n    },\n    address: {\n      type: String,\n      default: null\n    },\n    proposalId: {\n      type: Number,\n      default: null\n    },\n    proposalTitle: {\n      type: String,\n      default: null\n    },\n    selectedChainName: {\n      type: String,\n      default: null\n    },\n    toAddress: {\n      type: String,\n      default: null\n    }\n  },\n\n  data() {\n    return {\n      modalTitle: '',\n      historyName: '',\n      selectedValidator: null,\n      token: '',\n      chainId: '',\n      balance: [],\n      IBCDenom: {},\n      error: null,\n      showDismissibleAlert: false,\n      sequence: 1,\n      accountNumber: 0,\n      advance: false,\n      fee: '900',\n      feeDenom: '',\n      wallet: 'ledgerUSB',\n      gas: '250000',\n      memo: '',\n      blockingMsg: this.address ? 'You are not the owner' : 'No available account found.',\n      actionName: 'Send',\n      showResult: false,\n      txHash: '',\n      required,\n      password,\n      email,\n      min,\n      integer,\n      url,\n      alpha,\n      between,\n      digits,\n      length,\n      alphaDash\n    };\n  },\n\n  computed: {\n    feeDenoms() {\n      if (!this.balance) return [];\n      return this.balance.filter(item => !item.denom.startsWith('ibc'));\n    },\n\n    accounts() {\n      const accounts = getLocalAccounts();\n      const selectedWallet = this.$store.state.chains.defaultWallet;\n      return accounts ? accounts[selectedWallet] : null;\n    },\n\n    isOwner() {\n      if (this.accounts) {\n        this.updateWallet(this.accounts.device);\n\n        if (this.accounts.address.findIndex(x => x.addr === this.selectedAddress) > -1) {\n          return true;\n        }\n      }\n\n      return false;\n    },\n\n    selectedAddress() {\n      if (this.address) {\n        return this.address;\n      }\n\n      if (this.accounts) {\n        const chain = this.$store.state.chains.selected.chain_name;\n        const selectedAddress = this.accounts?.address.find(x => x.chain === chain);\n        return selectedAddress?.addr;\n      }\n\n      return null;\n    },\n\n    selectedChain() {\n      let config = null;\n      const allChains = localStorage.getItem('chains');\n\n      if (allChains && this.selectedChainName) {\n        config = JSON.parse(allChains)[this.selectedChainName];\n      }\n\n      return config;\n    }\n\n  },\n  methods: {\n    initialize() {\n      if (this.isOwner && this.selectedAddress) {\n        this.$http.getLatestBlock().then(ret => {\n          this.chainId = ret.block.header.chain_id;\n          const notSynced = timeIn(ret.block.header.time, 10, 'm');\n\n          if (notSynced) {\n            this.error = 'Client is not synced or blockchain is halted';\n          } else {\n            this.error = null;\n          }\n        });\n        this.$http.getAuthAccount(this.selectedAddress).then(ret => {\n          const account = extractAccountNumberAndSequence(ret);\n          this.accountNumber = account.accountNumber;\n          this.sequence = account.sequence;\n        });\n        this.$http.getBankBalances(this.selectedAddress, this.selectedChain).then(res => {\n          if (res.balances && res.balances.length > 0) {\n            this.balance = res.balances.reverse();\n            const token = this.balance.find(i => !i.denom.startsWith('ibc'));\n            this.token = token.denom;\n            if (token) this.feeDenom = token.denom;\n          }\n        });\n        this.fee = this.$store.state.chains.selected?.min_tx_fee || '1000';\n        this.feeDenom = this.$store.state.chains.selected?.assets[0]?.base || '';\n      }\n    },\n\n    componentUpdate(obj) {\n      Object.keys(obj).forEach(key => {\n        this[key] = obj[key];\n      });\n    },\n\n    handleOk(bvModalEvt) {\n      bvModalEvt.preventDefault();\n\n      if (!this.fee) {\n        this.error = 'fee is required';\n        return;\n      }\n\n      if (!this.feeDenom) {\n        this.error = 'fee symbol is required';\n        return;\n      }\n\n      if (!this.accountNumber) {\n        this.error = 'Account number is required';\n        return;\n      }\n\n      if (!this.sequence) {\n        this.error = 'Sequence is required';\n        return;\n      }\n\n      if (!this.chainId) {\n        this.error = 'Chain Id is required';\n        return;\n      }\n\n      this.$refs.simpleRules.validate().then(ok => {\n        if (ok) {\n          this.sendTx().then(ret => {\n            this.error = ret;\n          });\n        }\n      });\n    },\n\n    resetModal() {\n      this.feeDenom = '';\n      this.error = null;\n      this.showResult = false;\n    },\n\n    async sendTx() {\n      const txMsgs = this.$refs.component.msg;\n\n      if (txMsgs.length === 0) {\n        this.error = 'No delegation found';\n        return '';\n      }\n\n      if (!this.accountNumber) {\n        this.error = 'Account number should not be empty!';\n        return '';\n      }\n\n      const txFee = {\n        amount: [{\n          amount: this.fee,\n          denom: this.feeDenom\n        }],\n        gas: this.gas\n      };\n      const signerData = {\n        accountNumber: this.accountNumber,\n        sequence: this.sequence,\n        chainId: this.chainId\n      };\n      sign(this.wallet, this.chainId, this.selectedAddress, txMsgs, txFee, this.memo, signerData).then(bodyBytes => {\n        this.showResult = true;\n        this.$http.broadcastTx(bodyBytes, this.selectedChain).then(res => {\n          this.txHash = res.tx_response.txhash;\n          setLocalTxHistory({\n            chain: this.$store.state.chains.selected,\n            op: this.historyName,\n            hash: res.tx_response.txhash,\n            time: new Date()\n          });\n        }).catch(e => {\n          this.showResult = false;\n          this.error = e;\n          this.showDismissibleAlert = true;\n        });\n      }).catch(e => {\n        this.showResult = false;\n        this.error = e;\n        this.showDismissibleAlert = true;\n      });\n      return '';\n    },\n\n    updateWallet(v) {\n      if (v && v === 'address') {\n        this.wallet = 'keplr';\n      } else {\n        this.wallet = v;\n      }\n    }\n\n  }\n};","map":null,"metadata":{},"sourceType":"module"}