{"ast":null,"code":"import _createClass from \"/root/explorer/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _classCallCheck from \"/root/explorer/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _typeof from \"/root/explorer/node_modules/@babel/runtime/helpers/esm/typeof.js\";\nimport _asyncToGenerator from \"/root/explorer/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport \"regenerator-runtime/runtime.js\";\nimport \"core-js/modules/es.json.stringify.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.string.replace.js\";\nimport \"core-js/modules/es.string.starts-with.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.object.values.js\";\nimport \"core-js/modules/es.array.slice.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\nimport \"core-js/modules/es.array.find.js\";\nimport \"core-js/modules/es.regexp.test.js\";\nimport \"core-js/modules/es.number.to-fixed.js\";\nimport \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/es.object.keys.js\";\nimport \"core-js/modules/es.array.join.js\";\nimport \"core-js/modules/es.array.find-index.js\";\nimport \"core-js/modules/es.array.includes.js\";\nimport \"core-js/modules/es.string.includes.js\";\nimport \"core-js/modules/es.number.constructor.js\";\nimport \"core-js/modules/es.string.split.js\";\nimport \"core-js/modules/es.regexp.to-string.js\";\nimport \"core-js/modules/es.string.search.js\";\nimport \"core-js/modules/es.symbol.js\";\nimport \"core-js/modules/es.symbol.description.js\";\nimport \"core-js/modules/es.error.cause.js\";\nimport { Bech32, fromBase64, fromBech32, fromHex, toBase64, toBech32, toHex } from '@cosmjs/encoding';\nimport { sha256, stringToPath } from '@cosmjs/crypto'; // ledger\n\nimport TransportWebBLE from '@ledgerhq/hw-transport-web-ble';\nimport TransportWebUSB from '@ledgerhq/hw-transport-webusb';\nimport CosmosApp from 'ledger-cosmos-js';\nimport { LedgerSigner } from '@cosmjs/ledger-amino';\nimport { ethToEvmos } from '@tharsis/address-converter';\nimport dayjs from 'dayjs';\nimport duration from 'dayjs/plugin/duration';\nimport relativeTime from 'dayjs/plugin/relativeTime';\nimport updateLocale from 'dayjs/plugin/updateLocale';\nimport utc from 'dayjs/plugin/utc';\nimport RIPEMD160 from 'ripemd160';\nimport localeData from 'dayjs/plugin/localeData';\nimport { $themeColors } from '@themeConfig'; // import { SigningStargateClient } from '@cosmjs/stargate'\n// import PingWalletClient from './data/signing'\n\nimport { SigningStargateClient } from '@cosmjs/stargate';\nimport { getSigningClient } from './client/SigningEthermintClient.ts';\nimport EthereumLedgerSigner from './client/EthereumLedgerSigner.ts';\nimport SigningKeplerEthermintClient from './client/SigningKeplrEthermintClient';\ndayjs.extend(localeData);\ndayjs.extend(duration);\ndayjs.extend(relativeTime);\ndayjs.extend(updateLocale);\ndayjs.extend(utc);\ndayjs.updateLocale('en', {\n  relativeTime: {\n    future: 'in %s',\n    past: '%s ago',\n    s: '%ds',\n    m: '1m',\n    mm: '%dm',\n    h: 'an hour',\n    hh: '%d hours',\n    d: 'a day',\n    dd: '%d days',\n    M: 'a month',\n    MM: '%d months',\n    y: 'a year',\n    yy: '%d years'\n  }\n});\nexport function getLocalObject(name) {\n  var text = localStorage.getItem(name);\n\n  if (text) {\n    return JSON.parse(text);\n  }\n\n  return null;\n}\nexport function getLocalChains() {\n  return getLocalObject('chains');\n}\nexport function getLocalAccounts() {\n  return getLocalObject('accounts');\n}\nexport function getLocalTxHistory() {\n  return getLocalObject('txHistory');\n}\nexport function setLocalTxHistory(tx) {\n  var newTx = tx;\n  var txs = getLocalTxHistory();\n\n  if (txs) {\n    txs.push(newTx);\n    return localStorage.setItem('txHistory', JSON.stringify(txs));\n  }\n\n  return localStorage.setItem('txHistory', JSON.stringify([newTx]));\n}\nexport function connectLedger() {\n  return _connectLedger.apply(this, arguments);\n}\n\nfunction _connectLedger() {\n  _connectLedger = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {\n    var transport,\n        trans,\n        _args = arguments;\n    return regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            transport = _args.length > 0 && _args[0] !== undefined ? _args[0] : 'usb';\n            _context.next = 3;\n            return transport;\n\n          case 3:\n            _context.t0 = _context.sent;\n\n            if (!(_context.t0 === 'usb')) {\n              _context.next = 8;\n              break;\n            }\n\n            _context.t1 = TransportWebUSB.create();\n            _context.next = 9;\n            break;\n\n          case 8:\n            _context.t1 = TransportWebBLE.create();\n\n          case 9:\n            trans = _context.t1;\n            return _context.abrupt(\"return\", new CosmosApp(trans));\n\n          case 11:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return _connectLedger.apply(this, arguments);\n}\n\nexport function operatorAddressToAccount(operAddress) {\n  var _Bech32$decode = Bech32.decode(operAddress),\n      prefix = _Bech32$decode.prefix,\n      data = _Bech32$decode.data;\n\n  if (prefix === 'iva') {\n    // handle special cases\n    return Bech32.encode('iaa', data);\n  }\n\n  if (prefix === 'crocncl') {\n    // handle special cases\n    return Bech32.encode('cro', data);\n  }\n\n  return Bech32.encode(prefix.replace('valoper', ''), data);\n} // TODO, not tested\n\nexport function pubkeyToAccountAddress(pubkey, prefix) {\n  return Bech32.encode(prefix, pubkey, 40);\n}\nexport function toETHAddress(cosmosAddress) {\n  return \"0x\".concat(toHex(fromBech32(cosmosAddress).data));\n}\nexport function addressDecode(address) {\n  if (address.startsWith('0x')) {\n    return fromBech32(ethToEvmos(address));\n  }\n\n  return fromBech32(address);\n}\nexport function addressEnCode(prefix, pubkey) {\n  return toBech32(prefix, pubkey);\n}\nexport function getUserCurrency() {\n  var currency = localStorage.getItem('currency');\n  return currency || 'usd';\n}\nexport function setUserCurrency(currency) {\n  localStorage.setItem('currency', currency);\n}\nexport function chartColors() {\n  var colors = ['#8A2BE2', '#9ACD32', '#000080', '#008080', '#DC143C', '#7FFFD4', '#B8860B', '#EEE8AA', '#FFFAFA', '#FDF5E6', '#C0C0C0', '#E6E6FA', '#FFFAF0', '#2E8B57', '#DCDCDC', '#FF1493', '#4682B4', '#191970', '#FF8C00', '#FFFFE0', '#696969', '#FFFACD', '#DEB887', '#4169E1', '#9932CC', '#B0C4DE', '#556B2F', '#FFE4E1', '#F5FFFA', '#8FBC8F', '#B22222', '#90EE90', '#FFFF00', '#4B0082', '#DB7093', '#F8F8FF', '#006400', '#6610f2', '#FFA500', '#7FFF00', '#87CEFA', '#5F9EA0', '#483D8B', '#CD5C5C', '#ADFF2F', '#2F4F4F', '#00FF7F', '#FFF5EE', '#F4A460', '#808000', '#000000', '#00FA9A', '#000000', '#EE82EE', '#F5DEB3', '#0000FF', '#BA55D3', '#FFF0F5', '#F5F5DC', '#0000CD', '#FFD700', '#708090', '#6B8E23', '#800000', '#7B68EE', '#FFA07A', '#800080', '#B0E0E6', '#00FFFF', '#00BFFF', '#7CFC00', '#778899', '#FF7F50', '#E0FFFF', '#6495ED', '#008B8B', '#DDA0DD', '#CD853F', '#FFFFF0', '#98FB98', '#9400D3', '#D2691E', '#FF0000', '#008000', '#00008B', '#C71585', '#FFB6C1', '#8B4513', '#20c997', '#FAEBD7', '#E9967A', '#FFEFD5', '#FFE4C4', '#D8BFD8', '#A52A2A', '#8B0000', '#32CD32', '#BDB76B', '#FF0000', '#DAA520', '#800000', '#9370DB', '#F08080', '#FAF0E6', '#FF6347', '#FF4500', '#FFFF00', '#808080', '#00CED1', '#FFC0CB', '#FF00FF', '#F0FFFF', '#A9A9A9', '#F0E68C', '#1E90FF', '#FFDAB9', '#228B22', '#F0FFF0', '#66CDAA', '#ADD8E6', '#DA70D6', '#A0522D', '#FFE4B5', '#48D1CC', '#D2B48C', '#FFEBCD', '#8B008B', '#3CB371', '#87CEEB', '#6A5ACD', '#FFDEAD', '#FF69B4', '#BC8F8F', '#D3D3D3', '#00FF00', '#FAFAD2', '#AFEEEE', '#40E0D0', '#FFF8DC', '#20B2AA', '#00FFFF', '#FA8072', '#F0F8FF'];\n  return Object.values($themeColors).concat(colors);\n}\nexport function extractAccountNumberAndSequence(ret) {\n  var _account;\n\n  var account = ret.account;\n\n  if (account && account.base_vesting_account) {\n    var _account$base_vesting;\n\n    // vesting account\n    account = (_account$base_vesting = account.base_vesting_account) === null || _account$base_vesting === void 0 ? void 0 : _account$base_vesting.base_account;\n  } else if (account && account.base_account) {\n    // evmos based account\n    account = account.base_account;\n  }\n\n  var accountNumber = account.account_number;\n  var sequence = ((_account = account) === null || _account === void 0 ? void 0 : _account.sequence) || 0;\n  return {\n    accountNumber: accountNumber,\n    sequence: sequence\n  };\n}\nexport function getUserCurrencySign() {\n  var s = '';\n\n  switch (getUserCurrency()) {\n    case 'cny':\n    case 'jpy':\n      s = '¥';\n      break;\n\n    case 'krw':\n      s = '₩';\n      break;\n\n    case 'eur':\n      s = '€';\n      break;\n\n    default:\n      s = '$';\n  }\n\n  return s;\n}\nexport function consensusPubkeyToHexAddress(consensusPubkey) {\n  var raw = null;\n\n  if (_typeof(consensusPubkey) === 'object') {\n    if (consensusPubkey['@type'] === '/cosmos.crypto.ed25519.PubKey') {\n      // raw = toBase64(fromHex(toHex(sha256(fromBase64(consensusPubkey.key))).slice(0, 40)))\n      raw = toHex(sha256(fromBase64(consensusPubkey.key))).slice(0, 40).toUpperCase();\n      return raw;\n    } // /cosmos.crypto.secp256k1.PubKey\n\n\n    if (consensusPubkey['@type'] === '/cosmos.crypto.secp256k1.PubKey') {\n      raw = new RIPEMD160().update(Buffer.from(sha256(fromBase64(consensusPubkey.key)))).digest('hex');\n      return raw;\n    }\n\n    if (consensusPubkey.type === 'tendermint/PubKeySecp256k1') {\n      raw = new RIPEMD160().update(Buffer.from(sha256(fromBase64(consensusPubkey.value)))).digest('hex').toUpperCase();\n      return raw;\n    }\n\n    raw = sha256(fromBase64(consensusPubkey.value));\n  } else {\n    raw = sha256(fromHex(toHex(fromBech32(consensusPubkey).data).toUpperCase().replace('1624DE6420', '')));\n  }\n\n  var address = toHex(raw).slice(0, 40).toUpperCase();\n  return address;\n}\n\nfunction toSignAddress(addr) {\n  var _addressDecode = addressDecode(addr),\n      data = _addressDecode.data;\n\n  return addressEnCode('cosmos', data);\n}\n\nfunction getHdPath(address) {\n  var hdPath = \"m/44'/118/0'/0/0\";\n  Object.values(getLocalAccounts()).forEach(function (item) {\n    var curr = item.address.find(function (i) {\n      return i.addr === address;\n    });\n\n    if (curr && curr.hdpath) {\n      hdPath = curr.hdpath;\n    }\n  }); //  m/0'/1/2'/2/1000000000\n\n  return stringToPath(hdPath);\n}\n\nfunction isEvmosBasedChain(chainId) {\n  var re = /[_]{1}[\\d]{4}[\\\\-]{1}[\\d]+$/g;\n  return re.test(chainId);\n}\n\nexport function sign(_x, _x2, _x3, _x4, _x5, _x6, _x7) {\n  return _sign.apply(this, arguments);\n} // import address from ledger\n\nfunction _sign() {\n  _sign = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(device, chainId, signerAddress, messages, fee, memo, signerData) {\n    var hdpath, client, signer, _signer, coinType, addr;\n\n    return regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            hdpath = getHdPath(signerAddress);\n\n            if (!device.startsWith('ledger')) {\n              _context2.next = 7;\n              break;\n            }\n\n            _context2.next = 4;\n            return getSigningClient(device, hdpath);\n\n          case 4:\n            client = _context2.sent;\n            _context2.next = 22;\n            break;\n\n          case 7:\n            if (!(!window.getOfflineSigner || !window.keplr)) {\n              _context2.next = 9;\n              break;\n            }\n\n            throw new Error('Please install keplr extension');\n\n          case 9:\n            _context2.next = 11;\n            return window.keplr.enable(chainId);\n\n          case 11:\n            if (!isEvmosBasedChain(chainId)) {\n              _context2.next = 18;\n              break;\n            }\n\n            signer = window.getOfflineSigner(chainId);\n            _context2.next = 15;\n            return SigningKeplerEthermintClient.offline(signer);\n\n          case 15:\n            client = _context2.sent;\n            _context2.next = 22;\n            break;\n\n          case 18:\n            _signer = window.getOfflineSignerOnlyAmino(chainId);\n            _context2.next = 21;\n            return SigningStargateClient.offline(_signer);\n\n          case 21:\n            client = _context2.sent;\n\n          case 22:\n            coinType = Number(hdpath[1]);\n            addr = device.startsWith('ledger') && coinType !== 60 ? toSignAddress(signerAddress) : signerAddress;\n            return _context2.abrupt(\"return\", client.sign(addr, messages, fee, memo, signerData));\n\n          case 25:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n  return _sign.apply(this, arguments);\n}\n\nfunction getLedgerAppName(_x8, _x9, _x10) {\n  return _getLedgerAppName.apply(this, arguments);\n}\n\nfunction _getLedgerAppName() {\n  _getLedgerAppName = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(coinType, device, hdpath) {\n    var ledgerAppName, transport;\n    return regeneratorRuntime.wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            ledgerAppName = 'Cosmos';\n            _context3.t0 = coinType;\n            _context3.next = _context3.t0 === 60 ? 4 : _context3.t0 === 529 ? 5 : _context3.t0 === 852 ? 7 : _context3.t0 === 330 ? 9 : _context3.t0 === 118 ? 11 : 11;\n            break;\n\n          case 4:\n            return _context3.abrupt(\"return\", EthereumLedgerSigner.create(device, hdpath));\n\n          case 5:\n            ledgerAppName = 'Secret'; // 'Secret'\n\n            return _context3.abrupt(\"break\", 11);\n\n          case 7:\n            ledgerAppName = 'Desmos'; // 'Desmos'\n\n            return _context3.abrupt(\"break\", 11);\n\n          case 9:\n            ledgerAppName = 'Terra'; // 'Terra'\n\n            return _context3.abrupt(\"break\", 11);\n\n          case 11:\n            _context3.next = 13;\n            return device === 'ledgerBle' ? TransportWebBLE.create() : TransportWebUSB.create();\n\n          case 13:\n            transport = _context3.sent;\n            return _context3.abrupt(\"return\", new LedgerSigner(transport, {\n              hdPaths: [hdpath],\n              ledgerAppName: ledgerAppName\n            }));\n\n          case 15:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3);\n  }));\n  return _getLedgerAppName.apply(this, arguments);\n}\n\nexport function getLedgerAddress() {\n  return _getLedgerAddress.apply(this, arguments);\n} /// end import address from ledger\n\nfunction _getLedgerAddress() {\n  _getLedgerAddress = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4() {\n    var transport,\n        hdPath,\n        protocol,\n        coinType,\n        signer,\n        _args4 = arguments;\n    return regeneratorRuntime.wrap(function _callee4$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            transport = _args4.length > 0 && _args4[0] !== undefined ? _args4[0] : 'blu';\n            hdPath = _args4.length > 1 && _args4[1] !== undefined ? _args4[1] : \"m/44'/118/0'/0/0\";\n\n            if (!(transport === 'usb')) {\n              _context4.next = 8;\n              break;\n            }\n\n            _context4.next = 5;\n            return TransportWebUSB.create();\n\n          case 5:\n            _context4.t0 = _context4.sent;\n            _context4.next = 11;\n            break;\n\n          case 8:\n            _context4.next = 10;\n            return TransportWebBLE.create();\n\n          case 10:\n            _context4.t0 = _context4.sent;\n\n          case 11:\n            protocol = _context4.t0;\n            // extract Cointype from from HDPath\n            coinType = Number(stringToPath(hdPath)[1]);\n            _context4.next = 15;\n            return getLedgerAppName(coinType, protocol, stringToPath(hdPath));\n\n          case 15:\n            signer = _context4.sent;\n            return _context4.abrupt(\"return\", signer.getAccounts());\n\n          case 17:\n          case \"end\":\n            return _context4.stop();\n        }\n      }\n    }, _callee4);\n  }));\n  return _getLedgerAddress.apply(this, arguments);\n}\n\nexport function toDuration(value) {\n  return dayjs.duration(value).humanize();\n} // unit(y M d h m s ms)\n\nexport function timeIn(time, amount) {\n  var unit = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 's';\n  var input = dayjs(time).add(amount, unit);\n  return dayjs().unix() > input.unix();\n}\nexport function toDay(time) {\n  var format = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'long';\n\n  if (format === 'long') {\n    return dayjs(time).format('YYYY-MM-DD HH:mm');\n  }\n\n  if (format === 'date') {\n    return dayjs(time).format('YYYY-MM-DD');\n  }\n\n  if (format === 'time') {\n    return dayjs(time).format('HH:mm:ss');\n  }\n\n  if (format === 'from') {\n    return dayjs(time).fromNow();\n  }\n\n  if (format === 'to') {\n    return dayjs(time).toNow();\n  }\n\n  return dayjs(time).format('YYYY-MM-DD HH:mm:ss');\n}\nexport function percent(num) {\n  return parseFloat((num * 100).toFixed(2));\n}\nexport function abbr(string) {\n  var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 6;\n  var suffix = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '...';\n\n  if (string && string.length > length) {\n    return \"\".concat(string.substring(0, length)).concat(suffix);\n  }\n\n  return string;\n}\nexport function abbrRight(string) {\n  var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 6;\n  var suffix = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '...';\n\n  if (string && string.length > length) {\n    return \"\".concat(string.substring(string.length - length)).concat(suffix);\n  }\n\n  return string;\n}\nexport function abbrMessage(msg) {\n  if (Array.isArray(msg)) {\n    var sum = msg.map(function (x) {\n      return abbrMessage(x);\n    }).reduce(function (s, c) {\n      var sh = s;\n\n      if (sh[c]) {\n        sh[c] += 1;\n      } else {\n        sh[c] = 1;\n      }\n\n      return sh;\n    }, {});\n    var output = [];\n    Object.keys(sum).forEach(function (k) {\n      output.push(sum[k] > 1 ? \"\".concat(k, \"\\xD7\").concat(sum[k]) : k);\n    });\n    return output.join(', ');\n  }\n\n  if (msg['@type']) {\n    return msg['@type'].substring(msg['@type'].lastIndexOf('.') + 1).replace('Msg', '');\n  }\n\n  if (msg.typeUrl) {\n    return msg.typeUrl.substring(msg.typeUrl.lastIndexOf('.') + 1).replace('Msg', '');\n  }\n\n  return msg.type.substring(msg.type.lastIndexOf('/') + 1).replace('Msg', '');\n}\nexport function abbrAddress(address) {\n  var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 10;\n  return address.substring(0, length).concat('...', address.substring(address.length - length));\n}\nexport function isStringArray(value) {\n  var is = false;\n\n  if (Array.isArray(value)) {\n    is = value.findIndex(function (x) {\n      return typeof x === 'string';\n    }) > -1;\n  }\n\n  return is;\n}\nexport function isToken(value) {\n  var is = false;\n\n  if (Array.isArray(value)) {\n    is = value.findIndex(function (x) {\n      return Object.keys(x).includes('denom');\n    }) > -1;\n  } else {\n    is = Object.keys(value).includes('denom');\n  }\n\n  return is;\n}\nexport function formatTokenDenom(tokenDenom) {\n  if (tokenDenom && tokenDenom.code === undefined) {\n    var denom = tokenDenom.denom_trace ? tokenDenom.denom_trace.base_denom : tokenDenom;\n    var chains = getLocalChains();\n    var selected = localStorage.getItem('selected_chain');\n    var selChain = chains[selected];\n    var nativeAsset = selChain.assets.find(function (a) {\n      return a.base === denom;\n    });\n\n    if (nativeAsset) {\n      denom = nativeAsset.symbol;\n    } else {\n      var config = Object.values(chains);\n      config.forEach(function (x) {\n        if (x.assets) {\n          var asset = x.assets.find(function (a) {\n            return a.base === denom;\n          });\n          if (asset) denom = asset.symbol;\n        }\n      });\n    }\n\n    return denom.length > 10 ? \"\".concat(denom.substring(0, 7).toUpperCase(), \"..\").concat(denom.substring(denom.length - 3)) : denom.toUpperCase();\n  }\n\n  return '';\n}\nexport function getUnitAmount(amount, tokenDenom) {\n  var denom = tokenDenom.denom_trace ? tokenDenom.denom_trace.base_denom : tokenDenom;\n  var exp = String(denom).startsWith('gravity') ? 18 : 6;\n  var config = Object.values(getLocalChains());\n  config.forEach(function (x) {\n    if (x.assets) {\n      var asset = x.assets.find(function (a) {\n        return a.base === denom;\n      });\n      if (asset) exp = asset.exponent;\n    }\n  }); // eslint-disable-next-line no-undef\n\n  return String(BigInt(Number(amount) * Math.pow(10, exp)));\n}\nexport function numberWithCommas(x) {\n  var parts = x.toString().split('.');\n  parts[0] = parts[0].replace(/\\B(?=(\\d{3})+(?!\\d))/g, ',');\n  return parts.join('.');\n}\nexport function formatTokenAmount(tokenAmount) {\n  var decimals = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;\n  var tokenDenom = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'uatom';\n  var format = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n  var denom = tokenDenom.denom_trace ? tokenDenom.denom_trace.base_denom : tokenDenom;\n  var amount = 0;\n  var exp = String(denom).startsWith('gravity') ? 18 : 6;\n  var config = Object.values(getLocalChains());\n  config.forEach(function (x) {\n    if (x.assets) {\n      var asset = x.assets.find(function (a) {\n        return a.base === denom;\n      });\n      if (asset) exp = asset.exponent;\n    }\n  });\n  amount = Number(Number(tokenAmount)) / Math.pow(10, exp);\n\n  if (amount > 10) {\n    if (format) {\n      return numberWithCommas(parseFloat(amount.toFixed(decimals)));\n    }\n\n    return parseFloat(amount.toFixed(decimals));\n  }\n\n  return parseFloat(amount.toFixed(exp));\n}\nexport function isTestnet() {\n  return window.location.hostname.startsWith('testnet') || window.location.search.indexOf('testnet') > -1;\n}\nexport function formatToken(token) {\n  var IBCDenom = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var decimals = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 2;\n  var withDenom = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n\n  if (token) {\n    var denom = IBCDenom[token.denom] || token.denom;\n\n    if (withDenom) {\n      return \"\".concat(formatTokenAmount(token.amount, decimals, denom), \" \").concat(formatTokenDenom(denom));\n    }\n\n    return formatTokenAmount(token.amount, decimals, denom);\n  }\n\n  return token;\n}\nvar COUNT_ABBRS = ['', 'K', 'M', 'B', 't', 'q', 's', 'S', 'o', 'n', 'd', 'U', 'D', 'T', 'Qt', 'Qd', 'Sd', 'St'];\nexport function formatNumber(count) {\n  var withAbbr = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  var decimals = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 2;\n  var i = count === 0 ? count : Math.floor(Math.log(count) / Math.log(1000));\n  var result = parseFloat((count / Math.pow(1000, i)).toFixed(decimals));\n\n  if (withAbbr && COUNT_ABBRS[i]) {\n    result += \"\".concat(COUNT_ABBRS[i]);\n  }\n\n  return result;\n}\nexport function tokenFormatter(tokens) {\n  var denoms = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var decimal = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 2;\n\n  if (Array.isArray(tokens)) {\n    return tokens.map(function (t) {\n      return formatToken(t, denoms, decimal);\n    }).join(', ');\n  }\n\n  return formatToken(tokens, denoms, 2);\n}\nexport function getCachedValidators(chainName) {\n  var locals = localStorage.getItem(\"validators-\".concat(chainName));\n  return locals;\n}\nexport function isHexAddress(v) {\n  // const re = /^[A-Z\\d]{40}$/\n  // return re.test(v)\n  return v.length === 28;\n}\nexport function getStakingValidatorByHex(chainName, textBase64) {\n  var locals = localStorage.getItem(\"validators-\".concat(chainName));\n\n  if (locals) {\n    var val = JSON.parse(locals).find(function (x) {\n      return toBase64(fromHex(consensusPubkeyToHexAddress(x.consensus_pubkey))) === textBase64;\n    });\n\n    if (val) {\n      return val.description.moniker;\n    }\n  }\n\n  return abbr(textBase64);\n}\nexport function getStakingValidatorByAccount(chainName, addr) {\n  var locals = localStorage.getItem(\"validators-\".concat(chainName));\n\n  if (locals) {\n    var val = JSON.parse(locals).find(function (x) {\n      return operatorAddressToAccount(x.operator_address) === addr;\n    });\n\n    if (val) {\n      return val.description.moniker;\n    }\n  }\n\n  return addr;\n}\nexport function getStakingValidatorOperator(chainName, addr) {\n  var length = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -1;\n  var locals = localStorage.getItem(\"validators-\".concat(chainName));\n\n  if (locals) {\n    var val = JSON.parse(locals).find(function (x) {\n      return x.operator_address === addr;\n    });\n\n    if (val) {\n      return val.description.moniker;\n    }\n  }\n\n  if (length > 0) {\n    return addr.substring(addr.length - length);\n  }\n\n  return addr;\n}\nexport * from 'compare-versions';\nexport * from './data';\nexport var Data = /*#__PURE__*/_createClass(function Data() {\n  _classCallCheck(this, Data);\n});","map":null,"metadata":{},"sourceType":"module"}