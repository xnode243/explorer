{"ast":null,"code":"//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\nimport { BRow, BCol, BAlert, BCard, BTable, BFormCheckbox, BCardHeader, BCardTitle, BMedia, BMediaAside, BMediaBody, BAvatar, BCardBody, BLink, BButtonGroup, BButton, BTooltip, VBModal, VBTooltip, BCardFooter, BProgress, BProgressBar, BBadge, BDropdown, BDropdownItem } from 'bootstrap-vue';\nimport { formatNumber, formatTokenAmount, isToken, percent, timeIn, toDay, toDuration, tokenFormatter, getLocalAccounts, getStakingValidatorOperator, formatToken } from '@/libs/utils';\nimport OperationModal from '@/views/components/OperationModal/index.vue';\nimport Ripple from 'vue-ripple-directive';\nimport dayjs from 'dayjs';\nimport VueMarkdown from 'vue-markdown';\nimport ParametersModuleComponent from './components/parameters/ParametersModuleComponent.vue';\nimport DashboardCardHorizontal from './components/dashboard/DashboardCardHorizontal.vue';\nimport DashboardCardVertical from './components/dashboard/DashboardCardVertical.vue';\nimport DashboardPriceChart2 from './components/dashboard/DashboardPriceChart2.vue';\nimport FeatherIcon from '../@core/components/feather-icon/FeatherIcon.vue';\nexport default {\n  components: {\n    BAvatar,\n    BButtonGroup,\n    BTooltip,\n    BButton,\n    BDropdown,\n    BDropdownItem,\n    BRow,\n    BCol,\n    BAlert,\n    BCard,\n    BTable,\n    BFormCheckbox,\n    BCardHeader,\n    BCardTitle,\n    BMediaBody,\n    BMediaAside,\n    BMedia,\n    BCardBody,\n    BLink,\n    BCardFooter,\n    BProgress,\n    BProgressBar,\n    VueMarkdown,\n    BBadge,\n    OperationModal,\n    ParametersModuleComponent,\n    DashboardCardHorizontal,\n    DashboardPriceChart2,\n    DashboardCardVertical,\n    FeatherIcon\n  },\n  directives: {\n    'b-modal': VBModal,\n    'b-tooltip': VBTooltip,\n    Ripple\n  },\n\n  data() {\n    return {\n      detailId: 0,\n      fields: ['validator', 'delegation', 'rewards', 'action'],\n      delegations: [],\n      rewards: [],\n      unbonding: [],\n      chain: this.$store.state.chains.selected.chain_name,\n      syncing: false,\n      latestTime: '',\n      marketData: null,\n      height: '-',\n      supply: '-',\n      bonded: '-',\n      validators: '-',\n      communityPool: '-',\n      ratio: '-',\n      inflation: '-',\n      proposals: [],\n      myVotes: {},\n      selectedValidator: '',\n      selectedProposalId: 0,\n      selectedTitle: '',\n      operationModalType: '',\n      tallyParam: null,\n      totalPower: 0,\n      voteColors: {\n        YES: 'success',\n        NO: 'warning',\n        ABSTAIN: 'info',\n        NO_WITH_VETO: 'danger'\n      },\n      walletBalances: '-',\n      walletStaking: '-',\n      walletRewards: '-',\n      walletUnbonding: '-',\n      address: null\n    };\n  },\n\n  computed: {\n    walletName() {\n      const key = this.$store?.state?.chains?.defaultWallet;\n\n      if (key) {\n        const accounts = getLocalAccounts() || {};\n        const account = Object.entries(accounts).map(v => ({\n          wallet: v[0],\n          address: v[1].address.find(x => x.chain === this.$store.state.chains.selected.chain_name)\n        })).filter(v => v.address).find(x => x.wallet === key);\n\n        if (account) {\n          this.fetchAccount(account.address.addr);\n        }\n      }\n\n      return key || 'Wallet';\n    },\n\n    proprosals2() {\n      return this.proposals;\n    },\n\n    stakingList() {\n      return this.delegations.map(x => {\n        const rewards = this.rewards.find(r => r.validator_address === x.delegation.validator_address);\n        const conf = this.$http.getSelectedConfig();\n        const decimal = conf.assets[0].exponent || '6';\n        return {\n          valAddress: x.delegation.validator_address,\n          validator: getStakingValidatorOperator(this.$store.state.chains.selected.chain_name, x.delegation.validator_address),\n          delegation: formatToken(x.balance, {}, decimal),\n          rewards: rewards ? this.formatToken(rewards.reward) : '',\n          action: ''\n        };\n      });\n    }\n\n  },\n\n  created() {\n    this.$http.getStakingParameters().then(res => {\n      Promise.all([this.$http.getStakingPool(), this.$http.getBankTotal(res.bond_denom)]).then(pool => {\n        this.supply = `${formatNumber(formatTokenAmount(pool[1].amount, 2, res.bond_denom, false), true, 2)}`;\n        this.bonded = `${formatNumber(formatTokenAmount(pool[0].bondedToken, 2, res.bond_denom, false), true, 2)}`;\n        this.ratio = `${percent(pool[0].bondedToken / pool[1].amount)}%`;\n        this.totalPower = pool[0].bondedToken;\n      });\n    });\n    this.$http.getGovernanceListByStatus(2).then(gov => {\n      this.proposals = gov.proposals;\n      this.proposals.forEach(p => {\n        this.$http.getGovernanceTally(p.id, 0).then(update => {\n          // const p2 = p\n          // p2.tally = update\n          // this.proposals.push(p2)\n          // this.proposals.sort((a, b) => a.id - b.id)\n          this.$set(p, 'tally', update);\n        });\n      });\n    });\n    this.$http.getLatestBlock().then(res => {\n      this.height = res.block.header.height;\n\n      if (timeIn(res.block.header.time, 3, 'm')) {\n        this.syncing = true;\n      } else {\n        this.syncing = false;\n      }\n\n      this.latestTime = toDay(res.block.header.time, 'long');\n      this.validators = res.block.last_commit.signatures.length;\n    });\n    this.$http.getCommunityPool().then(res => {\n      this.communityPool = this.formatToken(res.pool);\n    });\n    this.$http.getGovernanceParameterTallying().then(res => {\n      this.tallyParam = res;\n    });\n    const conf = this.$http.getSelectedConfig();\n\n    if (conf.excludes && conf.excludes.indexOf('mint') > -1) {\n      this.inflation = '-';\n    } else {\n      this.$http.getMintingInflation().then(res => {\n        this.inflation = `${percent(res)}%`;\n      }).catch(() => {\n        this.inflation = '-';\n      });\n    }\n  },\n\n  mounted() {\n    const elem = document.getElementById('txevent');\n    elem.addEventListener('txcompleted', () => {\n      const key = this.$store?.state?.chains?.defaultWallet;\n\n      if (key) {\n        const accounts = getLocalAccounts() || {};\n        const account = Object.entries(accounts).map(v => ({\n          wallet: v[0],\n          address: v[1].address.find(x => x.chain === this.$store.state.chains.selected.chain_name)\n        })).filter(v => v.address).find(x => x.wallet === key);\n\n        if (account) {\n          this.fetchAccount(account.address.addr);\n        }\n      }\n    });\n  },\n\n  methods: {\n    caculateTallyResult(tally) {\n      if (this.tallyParam && tally && this.totalPower > 0) {\n        if (tally.veto < Number(this.tallyParam.veto_threshold) && tally.yes > Number(this.tallyParam.threshold) && tally.total / this.totalPower > Number(this.tallyParam.quorum)) {\n          return 'pass';\n        }\n      }\n\n      return 'be rejected';\n    },\n\n    scaleWidth(p) {\n      if (this.tallyParam) {\n        return Number(this.tallyParam.quorum) * Number(this.tallyParam.threshold) * (1 - p.tally.abstain) * 100;\n      }\n\n      return 50;\n    },\n\n    selectProposal(modal, pid, title) {\n      this.operationModalType = modal;\n      this.selectedProposalId = Number(pid);\n      this.selectedTitle = title;\n    },\n\n    selectDelegation(v, type) {\n      this.selectedValidator = v.item.valAddress;\n      this.operationModalType = type;\n    },\n\n    selectSend() {\n      this.operationModalType = 'Transfer';\n    },\n\n    selectWithdraw() {\n      this.operationModalType = 'Withdraw';\n    },\n\n    formatToken(tokens) {\n      if (Array.isArray(tokens)) {\n        let nativeToken = tokens.filter(x => x.denom.length < 11);\n\n        if (tokens.length > 1) {\n          const sum = {};\n          const reduce = nativeToken.reduce((b, a) => {\n            const b2 = b;\n\n            if (b2[a.denom]) {\n              b2[a.denom] += Number(a.amount);\n            } else {\n              b2[a.denom] = Number(a.amount);\n            }\n\n            return b2;\n          }, sum);\n          nativeToken = Object.keys(reduce).map(k => ({\n            denom: k,\n            amount: reduce[k]\n          }));\n        }\n\n        return tokenFormatter(nativeToken, {}, 0);\n      }\n\n      return '-';\n    },\n\n    fetchAccount(address) {\n      this.address = address;\n      this.$http.getBankAccountBalance(address).then(bal => {\n        this.walletBalances = this.formatToken(bal);\n      });\n      this.$http.getStakingReward(address).then(res => {\n        this.rewards = res.rewards;\n        this.walletRewards = this.formatToken(res.rewards.map(x => x.reward).flat());\n      });\n      this.$http.getStakingDelegations(address).then(res => {\n        const delegations = res.delegation_responses || res;\n        this.delegations = delegations;\n        this.walletStaking = this.formatToken(delegations.map(x => x.balance).flat());\n      });\n      this.$http.getStakingUnbonding(address).then(res => {\n        const token = this.$store.state.chains.selected.assets[0];\n\n        if (token) {\n          const newTokens = [];\n          const denom = token.base;\n          const unbonding = res.unbonding_responses || res;\n          this.unbonding = unbonding;\n          unbonding.forEach(x => {\n            x.entries.forEach(y => {\n              newTokens.push({\n                amount: y.balance,\n                denom\n              });\n            });\n          });\n\n          if (newTokens.length > 0) {\n            this.walletUnbonding = this.formatToken(newTokens);\n          }\n        }\n      });\n      this.proposals.forEach(x => {\n        this.$http.getGovernanceProposalVote(x.id, address, null).then(v => {\n          this.myVotes[x.id] = this.formatVoteOption(v.vote.option);\n        }).catch(() => {\n          this.myVotes[x.id] = null;\n        });\n      });\n    },\n\n    formatVoteOption(v) {\n      return v.replaceAll('VOTE_OPTION_', '');\n    },\n\n    formatEnding(v) {\n      return toDay(v, 'from');\n    },\n\n    formatType(v) {\n      const txt = String(v).replace('Proposal', '');\n      const index = txt.lastIndexOf('.');\n      return index > 0 ? txt.substring(index + 1) : txt;\n    },\n\n    normalize(data, title) {\n      if (!data) return null;\n      const items = this.makeItems(data);\n      return {\n        title,\n        items\n      };\n    },\n\n    makeItems(data) {\n      return Object.keys(data).map(k => {\n        if (isToken(data[k])) {\n          return {\n            title: tokenFormatter(data[k]),\n            subtitle: k\n          };\n        }\n\n        if (typeof data[k] === 'boolean') {\n          return {\n            title: data[k],\n            subtitle: k\n          };\n        }\n\n        return {\n          title: this.convert(data[k]),\n          subtitle: k\n        };\n      });\n    },\n\n    addNewLine(value) {\n      return value ? value.replace(/(?:\\\\[rn])+/g, '\\n') : '-';\n    },\n\n    percent: v => percent(v),\n\n    processBarLength(v) {\n      return percent(v);\n    },\n\n    formatDate: v => dayjs(v).format('YYYY-MM-DD HH:mm:ss'),\n\n    convert(v) {\n      if (typeof v === 'object') {\n        const v2 = {};\n        Object.entries(v).forEach(e => {\n          const k = e[0];\n          const x = e[1];\n          v2[k] = this.convert(x);\n        });\n        return v2;\n      }\n\n      const d = parseFloat(v);\n      if (d === 0) return '0';\n\n      if (d < 1.01) {\n        return `${percent(d)}%`;\n      }\n\n      if (d > 1000000000) {\n        return `${toDuration(d / 1000000)}`;\n      }\n\n      if (d > 0) {\n        return d.toFixed();\n      }\n\n      return v;\n    },\n\n    showDetail(id) {\n      if (this.detailId !== id) {\n        this.detailId = id;\n      } else {\n        this.detailId = 0;\n      }\n    }\n\n  }\n};","map":null,"metadata":{},"sourceType":"module"}