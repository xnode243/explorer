{"ast":null,"code":"import \"core-js/modules/es.array.includes.js\";\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\nimport { FormWizard, TabContent } from 'vue-form-wizard';\nimport { ValidationProvider, ValidationObserver } from 'vee-validate';\nimport ToastificationContent from '@core/components/toastification/ToastificationContent.vue'; // import 'vue-form-wizard/dist/vue-form-wizard.min.css'\n\nimport 'vue-form-wizard/dist/vue-form-wizard.min.css';\nimport MetaMaskSigner from '@/libs/client/MetaMaskSigner';\nimport { BAlert, BRow, BCol, BFormGroup, BFormInput, BFormRadio, BFormCheckbox, BAvatar, BInputGroup, BInputGroupPrepend, BFormRadioGroup, VBTooltip, BFormTextarea, BButton } from 'bootstrap-vue';\nimport { required } from '@validations';\nimport { addressDecode, addressEnCode, getLedgerAddress, getLocalAccounts } from '@/libs/utils';\nimport { toHex } from '@cosmjs/encoding';\nimport { stringToPath } from '@cosmjs/crypto';\nexport default {\n  components: {\n    BAlert,\n    BButton,\n    ValidationProvider,\n    ValidationObserver,\n    FormWizard,\n    TabContent,\n    BAvatar,\n    BRow,\n    BCol,\n    BFormGroup,\n    BFormInput,\n    BFormRadio,\n    BFormCheckbox,\n    BFormTextarea,\n    BInputGroup,\n    BInputGroupPrepend,\n    BFormRadioGroup,\n    // eslint-disable-next-line vue/no-unused-components\n    ToastificationContent\n  },\n  directives: {\n    'b-tooltip': VBTooltip\n  },\n\n  data() {\n    return {\n      debug: '',\n      device: 'keplr',\n      address: '',\n      hdpath: \"m/44'/118/0'/0/0\",\n      name: '',\n      options: {},\n      required,\n      selected: [],\n      accounts: null,\n      exludes: [],\n      // HD Path is NOT supported,\n      edit: false,\n      keplr: '',\n      chainId: '',\n      error: null\n    };\n  },\n\n  computed: {\n    chains() {\n      const config = JSON.parse(localStorage.getItem('chains'));\n      this.exludes.forEach(x => {\n        delete config[x];\n      });\n      return config;\n    },\n\n    addresses() {\n      if (this.accounts && this.accounts.address) {\n        const {\n          data\n        } = addressDecode(this.accounts.address);\n        return this.selected.map(x => {\n          if (this.chains[x]) {\n            const {\n              logo,\n              addr_prefix,\n              coin_type\n            } = this.chains[x];\n            const addr = addressEnCode(addr_prefix, data, coin_type);\n            return {\n              chain: x,\n              addr,\n              logo,\n              hdpath: this.hdpath\n            };\n          }\n\n          return null;\n        }).filter(x => x != null);\n      }\n\n      return [];\n    }\n\n  },\n\n  mounted() {\n    const {\n      selected\n    } = this.$store.state.chains; // this.chain = selected\n\n    this.$http.getLatestBlock().then(res => {\n      this.chainId = res.block.header.chain_id;\n      this.keplr = this.initParamsForKeplr(this.chainId, selected);\n    });\n\n    if (selected && selected.chain_name && !this.exludes.includes(selected.chain_name)) {\n      this.selected.push(selected.chain_name);\n    }\n\n    const name = new URLSearchParams(window.location.search).get('name');\n    const wallets = getLocalAccounts();\n\n    if (name && wallets && wallets[name]) {\n      const wallet = wallets[name];\n      this.device = wallet.device;\n      this.name = wallet.name;\n      this.edit = true;\n\n      if (wallet.address) {\n        wallet.address.forEach(a => {\n          if (!this.selected.includes(a.chain)) {\n            this.selected.push(a.chain);\n          }\n        });\n        this.address = wallet.address[0].addr;\n        this.hdpath = wallet.address[0].hdpath;\n\n        if (this.localAddress()) {\n          this.$refs.wizard.nextTab();\n        }\n      }\n    } else {\n      this.hdpath = `m/44'/${selected.coin_type}/0'/0/0`;\n    }\n  },\n\n  methods: {\n    suggest() {\n      if (window.keplr) {\n        window.keplr.experimentalSuggestChain(JSON.parse(this.keplr)).catch(e => {\n          this.error = e;\n        });\n      }\n    },\n\n    initParamsForKeplr(chainid, chain) {\n      const gasPriceStep = chain.keplr_price_step || {\n        low: 0.01,\n        average: 0.025,\n        high: 0.03\n      };\n      return JSON.stringify({\n        chainId: chainid,\n        chainName: chain.chain_name,\n        rpc: Array.isArray(chain.rpc) ? chain.rpc[0] : chain.rpc,\n        rest: Array.isArray(chain.api) ? chain.api[0] : chain.api,\n        bip44: {\n          coinType: Number(chain.coin_type)\n        },\n        coinType: Number(chain.coin_type),\n        bech32Config: {\n          bech32PrefixAccAddr: chain.addr_prefix,\n          bech32PrefixAccPub: `${chain.addr_prefix}pub`,\n          bech32PrefixValAddr: `${chain.addr_prefix}valoper`,\n          bech32PrefixValPub: `${chain.addr_prefix}valoperpub`,\n          bech32PrefixConsAddr: `${chain.addr_prefix}valcons`,\n          bech32PrefixConsPub: `${chain.addr_prefix}valconspub`\n        },\n        currencies: [{\n          coinDenom: chain.assets[0].symbol,\n          coinMinimalDenom: chain.assets[0].base,\n          coinDecimals: Number(chain.assets[0].exponent),\n          coinGeckoId: chain.assets[0].coingecko_id || 'unknown'\n        }],\n        feeCurrencies: [{\n          coinDenom: chain.assets[0].symbol,\n          coinMinimalDenom: chain.assets[0].base,\n          coinDecimals: Number(chain.assets[0].exponent),\n          coinGeckoId: chain.assets[0].coingecko_id || 'unknown',\n          gasPriceStep\n        }],\n        gasPriceStep,\n        stakeCurrency: {\n          coinDenom: chain.assets[0].symbol,\n          coinMinimalDenom: chain.assets[0].base,\n          coinDecimals: Number(chain.assets[0].exponent),\n          coinGeckoId: chain.assets[0].coingecko_id || 'unknown'\n        },\n        features: chain.keplr_features || []\n      }, null, '\\t');\n    },\n\n    formatPubkey(v) {\n      if (typeof v === 'string') {\n        return v;\n      }\n\n      if (v) {\n        return toHex(v);\n      }\n\n      return '';\n    },\n\n    async connect() {\n      const transport = this.device === 'ledger' ? 'usb' : 'bluetooth';\n      return getLedgerAddress(transport, this.hdpath);\n    },\n\n    async cennectKeplr() {\n      if (!window.getOfflineSigner || !window.keplr) {\n        this.debug = 'Please install keplr extension';\n        return null;\n      } // const chainId = 'cosmoshub'\n\n\n      const chainId = await this.$http.getLatestBlock().then(ret => ret.block.header.chain_id);\n      await window.keplr.enable(chainId);\n      const offlineSigner = window.getOfflineSigner(chainId);\n      return offlineSigner.getAccounts();\n    },\n\n    async connectMetamask() {\n      if (!window.ethereum) {\n        this.debug = 'Please install Metamask extension';\n        return null;\n      }\n\n      const signer = MetaMaskSigner.create(stringToPath(this.hdpath));\n      return signer.getAccounts();\n    },\n\n    localAddress() {\n      if (!this.address) return false;\n\n      try {\n        const {\n          data\n        } = addressDecode(this.address);\n\n        if (data) {\n          this.accounts = {\n            address: this.address,\n            pubkey: data\n          };\n          return true;\n        }\n      } catch (e) {\n        this.debug = e;\n      }\n\n      return false;\n    },\n\n    formSubmitted() {\n      const string = localStorage.getItem('accounts');\n      const accounts = string ? JSON.parse(string) : {};\n      accounts[this.name] = {\n        name: this.name,\n        device: this.device,\n        address: this.addresses\n      };\n      localStorage.setItem('accounts', JSON.stringify(accounts));\n\n      if (!this.$store.state.chains.defaultWallet) {\n        this.$store.commit('setDefaultWallet', this.name);\n      }\n\n      this.$toast({\n        component: ToastificationContent,\n        props: {\n          title: 'Address Saved!',\n          icon: 'EditIcon',\n          variant: 'success'\n        }\n      });\n      this.$router.push('./accounts');\n    },\n\n    async validationFormDevice() {\n      let ok = String(this.name).length > 0;\n\n      if (!ok) {\n        // new import, otherwise it's edit mode.\n        switch (this.device) {\n          case 'keplr':\n            await this.cennectKeplr().then(accounts => {\n              if (accounts) {\n                // eslint-disable-next-line prefer-destructuring\n                this.accounts = accounts[0];\n                ok = true;\n              }\n            });\n            break;\n\n          case 'metamask':\n            await this.connectMetamask().then(accounts => {\n              if (accounts) {\n                // eslint-disable-next-line prefer-destructuring\n                this.accounts = accounts[0];\n                ok = true;\n              }\n            }).catch(e => {\n              this.debug = e;\n            });\n            break;\n\n          case 'ledger':\n          case 'ledger2':\n            await this.connect().then(accounts => {\n              if (accounts) {\n                // eslint-disable-next-line prefer-destructuring\n                this.accounts = accounts[0];\n                ok = true;\n              }\n            }).catch(e => {\n              this.debug = e;\n            });\n            break;\n\n          default:\n            ok = this.localAddress();\n        }\n      }\n\n      return new Promise((resolve, reject) => {\n        this.$refs.deviceRules.validate().then(success => {\n          if (ok && success) {\n            resolve(true);\n          }\n\n          reject();\n        });\n      });\n    },\n\n    validationFormAddress() {\n      return new Promise((resolve, reject) => {\n        this.$refs.accountRules.validate().then(success => {\n          if (success) {\n            resolve(true);\n          } else {\n            reject();\n          }\n        });\n      });\n    }\n\n  }\n};","map":null,"metadata":{},"sourceType":"module"}