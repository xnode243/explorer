{"ast":null,"code":"//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\nimport { BTable, BMedia, BAvatar, BBadge, BCard, BCardHeader, BCardTitle, VBTooltip, BCardBody, BButton, BFormRadioGroup, BFormGroup, BCardFooter } from 'bootstrap-vue';\nimport { percent, StakingParameters, formatToken } from '@/libs/utils';\nimport { keybase } from '@/libs/fetch';\nimport OperationModal from '@/views/components/OperationModal/index.vue';\nimport DownloadExcel from 'vue-json-excel';\nexport default {\n  components: {\n    BCard,\n    BTable,\n    BMedia,\n    BAvatar,\n    BBadge,\n    BCardHeader,\n    BCardTitle,\n    BCardBody,\n    BButton,\n    BFormRadioGroup,\n    BFormGroup,\n    BCardFooter,\n    OperationModal,\n    DownloadExcel\n  },\n  directives: {\n    'b-tooltip': VBTooltip\n  },\n\n  data() {\n    return {\n      islive: true,\n      validator_address: null,\n      mintInflation: 0,\n      stakingPool: 1,\n      stakingParameters: new StakingParameters(),\n      validators: [],\n      delegations: [],\n      changes: {},\n      latestPower: {},\n      previousPower: {},\n      excelCols: {\n        Validator: 'description.moniker',\n        Identity: 'description.identity',\n        Website: 'description.website',\n        'Operator Address': 'operator_address',\n        Status: 'status',\n        'Bonded Tokens': 'tokens',\n        'Formated Bonded Tokens': {\n          field: 'tokens',\n          callback: value => this.tokenFormatter(value, this.stakingParameters.bond_denom)\n        },\n        Percent: {\n          field: 'tokens',\n          callback: value => this.percent(value / this.stakingPool)\n        },\n        '24h Changes': 'changes',\n        'Unbonding Height': 'unbonding_height',\n        'Unbonding Time': 'unbonding_time'\n      },\n      validator_fields: [{\n        key: 'index',\n        label: '#',\n        tdClass: 'd-none d-md-block',\n        thClass: 'd-none d-md-block'\n      }, {\n        key: 'description',\n        label: 'Validator'\n      }, {\n        key: 'tokens',\n        label: 'Voting Power',\n        sortable: true,\n        tdClass: 'text-right',\n        thClass: 'text-right',\n        sortByFormatted: true\n      }, {\n        key: 'changes',\n        label: '24H Changes'\n      }, {\n        key: 'commission',\n        formatter: value => `${percent(value.rate)}%`,\n        tdClass: 'text-right',\n        thClass: 'text-right'\n      }, {\n        key: 'operation',\n        label: '',\n        tdClass: 'text-right',\n        thClass: 'text-right'\n      }],\n      statusOptions: [{\n        text: 'Active',\n        value: 'active'\n      }, {\n        text: 'Inactive',\n        value: 'inactive'\n      }],\n      selectedStatus: 'active',\n      isInactiveLoaded: false,\n      inactiveValidators: []\n    };\n  },\n\n  computed: {\n    pingVals() {\n      return this.list.filter(x => x.description.identity === '1FA0C152D18D9E60');\n    },\n\n    list() {\n      const tab = this.selectedStatus === 'active' ? this.validators : this.inactiveValidators;\n      return tab.map(x => {\n        const xh = x;\n\n        if (Object.keys(this.latestPower).length > 0 && Object.keys(this.previousPower).length > 0) {\n          const latest = this.latestPower[x.consensus_pubkey.key] || 0;\n          const previous = this.previousPower[x.consensus_pubkey.key] || 0;\n          xh.changes = latest - previous;\n        }\n\n        return xh;\n      });\n    }\n\n  },\n\n  created() {\n    this.$http.getStakingPool().then(pool => {\n      this.stakingPool = pool.bondedToken;\n    }); // set\n\n    this.$http.getStakingParameters().then(res => {\n      this.stakingParameters = res;\n    });\n    this.initial();\n  },\n\n  beforeDestroy() {\n    this.islive = false;\n  },\n\n  mounted() {\n    const elem = document.getElementById('txevent');\n    elem.addEventListener('txcompleted', () => {\n      this.initial();\n    });\n  },\n\n  methods: {\n    initial() {\n      this.$http.getValidatorList().then(res => {\n        const identities = [];\n        const temp = res;\n\n        for (let i = 0; i < temp.length; i += 1) {\n          const {\n            identity\n          } = temp[i].description;\n          const url = this.$store.getters['chains/getAvatarById'](identity);\n\n          if (url) {\n            temp[i].avatar = url;\n          } else if (identity && identity !== '') {\n            identities.push(identity);\n          }\n        } // fetch avatar from keybase\n\n\n        let promise = Promise.resolve();\n        identities.forEach(item => {\n          promise = promise.then(() => new Promise(resolve => {\n            this.avatar(item, resolve);\n          }));\n        });\n        this.validators = temp;\n        this.getPreviousPower(this.validators.length);\n      });\n    },\n\n    getPreviousPower(length) {\n      this.$http.getValidatorListByHeight('latest', 0).then(data => {\n        let height = Number(data.block_height);\n\n        if (height > 14400) {\n          height -= 14400;\n        } else {\n          height = 1;\n        }\n\n        data.validators.forEach(x => {\n          this.$set(this.latestPower, x.pub_key.key, Number(x.voting_power));\n        });\n\n        for (let offset = 100; offset < length; offset += 100) {\n          this.$http.getValidatorListByHeight('latest', offset).then(latest => {\n            latest.validators.forEach(x => {\n              this.$set(this.latestPower, x.pub_key.key, Number(x.voting_power));\n            });\n          });\n        }\n\n        for (let offset = 0; offset < length; offset += 100) {\n          this.$http.getValidatorListByHeight(height, offset).then(previous => {\n            previous.validators.forEach(x => {\n              this.$set(this.previousPower, x.pub_key.key, Number(x.voting_power));\n            });\n          });\n        }\n      });\n    },\n\n    getValidatorListByStatus() {\n      if (this.isInactiveLoaded) return;\n      const statusList = ['BOND_STATUS_UNBONDED', 'BOND_STATUS_UNBONDING'];\n      statusList.forEach(status => {\n        this.$http.getValidatorListByStatus(status).then(res => {\n          const identities = [];\n          const temp = res;\n\n          for (let i = 0; i < temp.length; i += 1) {\n            const {\n              identity\n            } = temp[i].description;\n            const url = this.$store.getters['chains/getAvatarById'](identity);\n\n            if (url) {\n              temp[i].avatar = url;\n            } else if (identity && identity !== '') {\n              identities.push(identity);\n            }\n          } // fetch avatar from keybase\n\n\n          let promise = Promise.resolve();\n          identities.forEach(item => {\n            promise = promise.then(() => new Promise(resolve => {\n              this.avatar(item, resolve);\n            }));\n          });\n          this.inactiveValidators = this.inactiveValidators.concat(res);\n        });\n      });\n      this.isInactiveLoaded = true;\n    },\n\n    selectValidator(da) {\n      this.validator_address = da;\n    },\n\n    percent,\n\n    tokenFormatter(amount, denom) {\n      return formatToken({\n        amount,\n        denom\n      }, {}, 0);\n    },\n\n    rankBadge(data) {\n      if (this.selectedStatus === 'inactive') return 'primary';\n      const {\n        index,\n        item\n      } = data;\n\n      if (index === 0) {\n        window.sum = 0;\n      }\n\n      const rank = window.sum / this.stakingPool;\n      window.sum += item.tokens; // sum up after the calculating.\n\n      if (rank < 0.333) {\n        return 'danger';\n      }\n\n      if (rank < 0.67) {\n        return 'warning';\n      }\n\n      return 'primary';\n    },\n\n    avatar(identity, resolve) {\n      if (this.islive) {\n        keybase(identity).then(d => {\n          resolve();\n\n          if (Array.isArray(d.them) && d.them.length > 0) {\n            const pic = d.them[0].pictures;\n\n            if (pic) {\n              const list = this.selectedStatus === 'active' ? this.validators : this.inactiveValidators;\n              const validator = list.find(u => u.description.identity === identity);\n              this.$set(validator, 'avatar', pic.primary.url);\n              this.$store.commit('cacheAvatar', {\n                identity,\n                url: pic.primary.url\n              });\n            }\n          }\n        });\n      }\n    }\n\n  }\n};","map":null,"metadata":{},"sourceType":"module"}