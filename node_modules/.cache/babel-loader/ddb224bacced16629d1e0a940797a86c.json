{"ast":null,"code":"//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\nimport { BCard, BCardHeader, BCardTitle, BCardBody, VBModal, BRow, BCol, BAvatar, BButton, BDropdown, BDropdownItem, VBTooltip } from 'bootstrap-vue';\nimport Ripple from 'vue-ripple-directive';\nimport FeatherIcon from '@/@core/components/feather-icon/FeatherIcon.vue';\nimport { chartColors, formatNumber, formatTokenAmount, formatTokenDenom, getLocalAccounts, getLocalChains, getUserCurrency, getUserCurrencySign, numberWithCommas, setUserCurrency } from '@/libs/utils';\nimport ToastificationContent from '@core/components/toastification/ToastificationContent.vue';\nimport AppCollapse from '@core/components/app-collapse/AppCollapse.vue';\nimport AppCollapseItem from '@core/components/app-collapse/AppCollapseItem.vue';\nimport OperationModal from '@/views/components/OperationModal/index.vue';\nimport ChartComponentDoughnut from './components/charts/ChartComponentDoughnut.vue';\nimport EchartScatter from './components/charts/EchartScatter.vue';\nexport default {\n  components: {\n    BAvatar,\n    BCard,\n    BRow,\n    BButton,\n    BCol,\n    BCardHeader,\n    BCardBody,\n    BCardTitle,\n    BDropdown,\n    BDropdownItem,\n    // eslint-disable-next-line vue/no-unused-components\n    VBTooltip,\n    FeatherIcon,\n    // eslint-disable-next-line vue/no-unused-components\n    ToastificationContent,\n    ChartComponentDoughnut,\n    AppCollapse,\n    AppCollapseItem,\n    EchartScatter,\n    OperationModal\n  },\n  directives: {\n    'b-tooltip': VBTooltip,\n    'b-modal': VBModal,\n    Ripple\n  },\n\n  data() {\n    return {\n      currency: getUserCurrencySign(),\n      currency2: getUserCurrency(),\n      selectedAddress: '',\n      selectedName: '',\n      transferWindow: false,\n      accounts: [],\n      balances: {},\n      delegations: {},\n      ibcDenom: {},\n      quotes: {},\n      operationModalType: '',\n      selectedChainName: '',\n      options: {\n        maintainAspectRatio: false,\n        legend: {\n          display: false\n        },\n        // responsive: true,\n        title: {\n          display: true,\n          text: 'Token Portfolio'\n        },\n        tooltips: {\n          mode: 'index',\n          intersect: true\n        },\n        scales: {\n          yAxes: [{\n            // type: 'linear', // only linear but allow scale type registration. This allows extensions to exist solely for log scale for instance\n            type: 'logarithmic',\n            display: true,\n            position: 'left',\n            id: 'y-axis-1',\n            ticks: {\n              min: 0,\n              autoskipping: true,\n              display: true,\n              maxTicksLimit: 7,\n\n              callback(val) {\n                return formatNumber(val, true, 0);\n              },\n\n              color: 'red'\n            },\n            offset: true,\n            gridLines: {\n              display: true,\n              offsetGridLines: false\n            }\n          }, {\n            type: 'linear',\n            // only linear but allow scale type registration. This allows extensions to exist solely for log scale for instance\n            display: false,\n            position: 'right',\n            id: 'y-axis-2',\n            gridLines: {\n              drawOnChartArea: true\n            }\n          }]\n        }\n      }\n    };\n  },\n\n  computed: {\n    calculateTotal() {\n      let total = 0;\n\n      if (this.calculateByDenom.value) {\n        Object.values(this.calculateByDenom.value).forEach(i => {\n          total += i;\n        });\n      }\n\n      return numberWithCommas(parseFloat(total.toFixed(2)));\n    },\n\n    scatters() {\n      const total = [];\n\n      if (this.calculateByDenom.qty) {\n        Object.entries(this.calculateByDenom.qty).forEach(i => {\n          const price = this.getPrice(i[0], 'usd'); // x, y, circle\n\n          total.push([Math.sqrt(i[1]), i[1] * price, price, i[0]]);\n        });\n      }\n\n      return total.sort((a, b) => b[2] - a[2]);\n    },\n\n    calculateTotalChange() {\n      let total = 0;\n\n      if (this.calculateByDenom.value) {\n        Object.entries(this.calculateByDenom.value).forEach(i => {\n          total += i[1] * this.getChanges(i[0]) * 0.01;\n        });\n      }\n\n      return parseFloat(total.toFixed(2));\n    },\n\n    calculateByDenom() {\n      const v = Object.values(this.balances);\n      const total = {};\n      const qty = {};\n\n      if (v) {\n        v.forEach(tokens => {\n          tokens.forEach(x => {\n            const denom = this.formatDenom(x.denom);\n\n            if (total[denom]) {\n              total[denom] += this.formatCurrency(x.amount, x.denom);\n            } else {\n              total[denom] = this.formatCurrency(x.amount, x.denom);\n            }\n\n            if (qty[denom]) {\n              qty[denom] += this.formatAmount(x.amount, x.denom, false);\n            } else {\n              qty[denom] = this.formatAmount(x.amount, x.denom, false);\n            }\n          });\n        });\n      }\n\n      const d = Object.values(this.delegations);\n\n      if (d) {\n        d.forEach(tokens => {\n          tokens.forEach(x => {\n            const denom = this.formatDenom(x.denom);\n\n            if (total[denom]) {\n              total[denom] += this.formatCurrency(x.amount, x.denom);\n            } else {\n              total[denom] = this.formatCurrency(x.amount, x.denom);\n            }\n\n            if (qty[denom]) {\n              qty[denom] += this.formatAmount(x.amount, x.denom, false);\n            } else {\n              qty[denom] = this.formatAmount(x.amount, x.denom, false);\n            }\n          });\n        });\n      }\n\n      return {\n        value: total,\n        qty\n      };\n    },\n\n    calculateChartDoughnut() {\n      const total = this.calculateByDenom;\n      const labels = [];\n      const data = [];\n      Object.entries(total.value).sort((a, b) => b[1] - a[1]).forEach(i => {\n        labels.push(i[0]);\n        data.push(i[1]);\n      });\n      return {\n        datasets: [{\n          labels,\n          data,\n          backgroundColor: chartColors(),\n          borderWidth: 0,\n          pointStyle: 'rectRounded'\n        }]\n      };\n    }\n\n  },\n\n  created() {\n    this.init();\n  },\n\n  methods: {\n    refreshPrice() {\n      this.$store.dispatch('chains/getQuotes');\n    },\n\n    init() {\n      this.balances = {};\n      this.delegations = {};\n      this.accounts = getLocalAccounts();\n      const chains = getLocalChains();\n\n      if (this.accounts) {\n        Object.keys(this.accounts).forEach(acc => {\n          this.accounts[acc].address.forEach(add => {\n            this.$http.getBankBalances(add.addr, chains[add.chain]).then(res => {\n              const {\n                balances\n              } = res;\n\n              if (balances && balances.length > 0) {\n                this.$set(this.balances, add.addr, balances);\n                balances.forEach(token => {\n                  if (token.denom.startsWith('ibc')) {\n                    this.$http.getIBCDenomTrace(token.denom, chains[add.chain]).then(denom => {\n                      this.$set(this.ibcDenom, token.denom, denom);\n                    });\n                  }\n                });\n              }\n            });\n            this.$http.getStakingDelegations(add.addr, chains[add.chain]).then(res => {\n              if (res.delegation_responses) {\n                const delegation = res.delegation_responses.map(x => x.balance).reduce((t, c) => {\n                  const t1 = t;\n\n                  if (t1[c.denom]) {\n                    t1[c.denom] += Number(c.amount);\n                  } else {\n                    t1[c.denom] = Number(c.amount);\n                  }\n\n                  return t1;\n                }, {});\n                this.$set(this.delegations, add.addr, Object.keys(delegation).map(x => ({\n                  amount: String(delegation[x]),\n                  denom: x\n                })));\n              }\n            }).catch(() => {});\n          });\n        });\n      }\n    },\n\n    setCurrency(c) {\n      setUserCurrency(c);\n      this.currency2 = c;\n      this.currency = getUserCurrencySign();\n    },\n\n    transfer(type, addr, chain) {\n      this.operationModalType = type;\n      this.selectedAddress = addr;\n      this.selectedChainName = chain;\n    },\n\n    completeAdd() {\n      this.init();\n      this.$bvModal.hide('add-account');\n    },\n\n    formatDenom(v) {\n      if (!v) return '';\n      const denom = v.startsWith('ibc') ? this.ibcDenom[v] : v;\n      return formatTokenDenom(denom);\n    },\n\n    formatTotalChange(v) {\n      return numberWithCommas(v);\n    },\n\n    formatAmount(v, denom = 'uatom', format = true) {\n      if (!v) return '';\n      const denom2 = denom.startsWith('ibc') ? this.ibcDenom[denom] : denom;\n      return formatTokenAmount(v, 2, denom2, format);\n    },\n\n    formatAddr(v) {\n      return v.substring(0, 10).concat('...', v.substring(v.length - 10));\n    },\n\n    formatCurrency(amount, denom) {\n      const qty = this.formatAmount(amount, denom, false);\n      return parseFloat((qty * this.getPrice(denom)).toFixed(2));\n    },\n\n    priceColor(denom) {\n      const d2 = this.formatDenom(denom);\n      const quote = this.$store.state.chains.quotes[d2];\n\n      if (quote) {\n        const price = quote[`${this.currency2}_24h_change`];\n        return price > 0 ? 'text-success' : 'text-danger';\n      }\n\n      return '';\n    },\n\n    getPrice(denom, currency = null) {\n      const d2 = this.formatDenom(denom);\n      const quote = this.$store.state.chains.quotes[d2];\n      return quote ? quote[currency || this.currency2 || 'usd'] || 0 : 0;\n    },\n\n    getChanges(denom) {\n      const d2 = this.formatDenom(denom);\n      const quote = this.$store.state.chains.quotes[d2];\n\n      if (quote) {\n        const price = quote[`${this.currency2}_24h_change`];\n        return price || 0;\n      }\n\n      return 0;\n    },\n\n    formatChanges(denom) {\n      const price = this.getChanges(denom);\n\n      if (price > 0) {\n        return `+${parseFloat(price.toFixed(2))}%`;\n      }\n\n      return '0';\n    },\n\n    formatPrice(denom) {\n      const d2 = this.formatDenom(denom);\n      const quote = this.$store.state.chains.quotes[d2];\n\n      if (quote) {\n        const price = quote[this.currency2];\n        return price;\n      }\n\n      return 0;\n    },\n\n    formatBalance(v) {\n      let total = 0;\n      const balance = this.balances[v];\n\n      if (balance) {\n        const ret = balance.map(x => this.formatCurrency(x.amount, x.denom)).reduce((t, c) => t + c);\n        total += ret;\n      }\n\n      const delegations = this.delegations[v];\n\n      if (delegations) {\n        const ret = delegations.map(x => this.formatCurrency(x.amount, x.denom)).reduce((t, c) => t + c, 0);\n        total += ret;\n      }\n\n      return numberWithCommas(parseFloat(total.toFixed(2)));\n    },\n\n    formatBalanceChanges(v) {\n      let total = 0;\n      const balance = this.balances[v];\n\n      if (balance) {\n        const ret = balance.map(x => this.formatCurrency(x.amount, x.denom) * this.getChanges(x.denom) * 0.01).reduce((t, c) => t + c);\n        total += ret;\n      }\n\n      const delegations = this.delegations[v];\n\n      if (delegations) {\n        const ret = delegations.map(x => this.formatCurrency(x.amount, x.denom) * this.getChanges(x.denom) * 0.01).reduce((t, c) => t + c, 0);\n        total += ret;\n      }\n\n      return total > 0 ? `+${parseFloat(total.toFixed(2))}` : parseFloat(total.toFixed(2));\n    },\n\n    formatBalanceChangesColor(v) {\n      const total = this.formatBalanceChanges(v);\n      return total > 0 ? 'text-success' : 'text-danger';\n    },\n\n    removeAddress(v) {\n      Object.keys(this.accounts).forEach(key => {\n        const item = this.accounts[key];\n        const newAddrs = item.address.filter(a => a.addr !== v);\n\n        if (newAddrs.length > 0) {\n          this.$delete(this.balances, v);\n          this.$delete(this.delegations, v);\n          this.$set(item, 'address', newAddrs);\n          localStorage.setItem('accounts', JSON.stringify(this.accounts));\n        } else {\n          delete this.accounts[key];\n          localStorage.setItem('accounts', JSON.stringify(this.accounts));\n          this.init();\n        }\n      });\n    },\n\n    disconnect(key) {\n      delete this.accounts[key];\n      localStorage.setItem('accounts', JSON.stringify(this.accounts));\n      this.init();\n    },\n\n    updateDefaultWallet(v) {\n      this.$store.commit('setDefaultWallet', v);\n    },\n\n    copy(v) {\n      this.$copyText(v).then(() => {\n        this.$toast({\n          component: ToastificationContent,\n          props: {\n            title: 'Address copied',\n            icon: 'BellIcon'\n          }\n        });\n      }, e => {\n        this.$toast({\n          component: ToastificationContent,\n          props: {\n            title: `Failed to copy address! ${e}`,\n            icon: 'BellIcon',\n            variant: 'danger'\n          }\n        });\n      });\n    }\n\n  }\n};","map":null,"metadata":{},"sourceType":"module"}