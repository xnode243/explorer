{"ast":null,"code":"import \"core-js/modules/es.array.includes.js\";\nimport { Bech32, fromBase64, fromBech32, fromHex, toBase64, toBech32, toHex } from '@cosmjs/encoding';\nimport { sha256, stringToPath } from '@cosmjs/crypto'; // ledger\n\nimport TransportWebBLE from '@ledgerhq/hw-transport-web-ble';\nimport TransportWebUSB from '@ledgerhq/hw-transport-webusb';\nimport CosmosApp from 'ledger-cosmos-js';\nimport { LedgerSigner } from '@cosmjs/ledger-amino';\nimport { ethToEvmos } from '@tharsis/address-converter';\nimport dayjs from 'dayjs';\nimport duration from 'dayjs/plugin/duration';\nimport relativeTime from 'dayjs/plugin/relativeTime';\nimport updateLocale from 'dayjs/plugin/updateLocale';\nimport utc from 'dayjs/plugin/utc';\nimport RIPEMD160 from 'ripemd160';\nimport localeData from 'dayjs/plugin/localeData';\nimport { $themeColors } from '@themeConfig'; // import { SigningStargateClient } from '@cosmjs/stargate'\n// import PingWalletClient from './data/signing'\n\nimport { SigningStargateClient } from '@cosmjs/stargate';\nimport { getSigningClient } from './client/SigningEthermintClient.ts';\nimport EthereumLedgerSigner from './client/EthereumLedgerSigner.ts';\nimport SigningKeplerEthermintClient from './client/SigningKeplrEthermintClient';\ndayjs.extend(localeData);\ndayjs.extend(duration);\ndayjs.extend(relativeTime);\ndayjs.extend(updateLocale);\ndayjs.extend(utc);\ndayjs.updateLocale('en', {\n  relativeTime: {\n    future: 'in %s',\n    past: '%s ago',\n    s: '%ds',\n    m: '1m',\n    mm: '%dm',\n    h: 'an hour',\n    hh: '%d hours',\n    d: 'a day',\n    dd: '%d days',\n    M: 'a month',\n    MM: '%d months',\n    y: 'a year',\n    yy: '%d years'\n  }\n});\nexport function getLocalObject(name) {\n  const text = localStorage.getItem(name);\n\n  if (text) {\n    return JSON.parse(text);\n  }\n\n  return null;\n}\nexport function getLocalChains() {\n  return getLocalObject('chains');\n}\nexport function getLocalAccounts() {\n  return getLocalObject('accounts');\n}\nexport function getLocalTxHistory() {\n  return getLocalObject('txHistory');\n}\nexport function setLocalTxHistory(tx) {\n  const newTx = tx;\n  const txs = getLocalTxHistory();\n\n  if (txs) {\n    txs.push(newTx);\n    return localStorage.setItem('txHistory', JSON.stringify(txs));\n  }\n\n  return localStorage.setItem('txHistory', JSON.stringify([newTx]));\n}\nexport async function connectLedger(transport = 'usb') {\n  const trans = (await transport) === 'usb' ? TransportWebUSB.create() : TransportWebBLE.create();\n  return new CosmosApp(trans);\n}\nexport function operatorAddressToAccount(operAddress) {\n  const {\n    prefix,\n    data\n  } = Bech32.decode(operAddress);\n\n  if (prefix === 'iva') {\n    // handle special cases\n    return Bech32.encode('iaa', data);\n  }\n\n  if (prefix === 'crocncl') {\n    // handle special cases\n    return Bech32.encode('cro', data);\n  }\n\n  return Bech32.encode(prefix.replace('valoper', ''), data);\n} // TODO, not tested\n\nexport function pubkeyToAccountAddress(pubkey, prefix) {\n  return Bech32.encode(prefix, pubkey, 40);\n}\nexport function toETHAddress(cosmosAddress) {\n  return `0x${toHex(fromBech32(cosmosAddress).data)}`;\n}\nexport function addressDecode(address) {\n  if (address.startsWith('0x')) {\n    return fromBech32(ethToEvmos(address));\n  }\n\n  return fromBech32(address);\n}\nexport function addressEnCode(prefix, pubkey) {\n  return toBech32(prefix, pubkey);\n}\nexport function getUserCurrency() {\n  const currency = localStorage.getItem('currency');\n  return currency || 'usd';\n}\nexport function setUserCurrency(currency) {\n  localStorage.setItem('currency', currency);\n}\nexport function chartColors() {\n  const colors = ['#8A2BE2', '#9ACD32', '#000080', '#008080', '#DC143C', '#7FFFD4', '#B8860B', '#EEE8AA', '#FFFAFA', '#FDF5E6', '#C0C0C0', '#E6E6FA', '#FFFAF0', '#2E8B57', '#DCDCDC', '#FF1493', '#4682B4', '#191970', '#FF8C00', '#FFFFE0', '#696969', '#FFFACD', '#DEB887', '#4169E1', '#9932CC', '#B0C4DE', '#556B2F', '#FFE4E1', '#F5FFFA', '#8FBC8F', '#B22222', '#90EE90', '#FFFF00', '#4B0082', '#DB7093', '#F8F8FF', '#006400', '#6610f2', '#FFA500', '#7FFF00', '#87CEFA', '#5F9EA0', '#483D8B', '#CD5C5C', '#ADFF2F', '#2F4F4F', '#00FF7F', '#FFF5EE', '#F4A460', '#808000', '#000000', '#00FA9A', '#000000', '#EE82EE', '#F5DEB3', '#0000FF', '#BA55D3', '#FFF0F5', '#F5F5DC', '#0000CD', '#FFD700', '#708090', '#6B8E23', '#800000', '#7B68EE', '#FFA07A', '#800080', '#B0E0E6', '#00FFFF', '#00BFFF', '#7CFC00', '#778899', '#FF7F50', '#E0FFFF', '#6495ED', '#008B8B', '#DDA0DD', '#CD853F', '#FFFFF0', '#98FB98', '#9400D3', '#D2691E', '#FF0000', '#008000', '#00008B', '#C71585', '#FFB6C1', '#8B4513', '#20c997', '#FAEBD7', '#E9967A', '#FFEFD5', '#FFE4C4', '#D8BFD8', '#A52A2A', '#8B0000', '#32CD32', '#BDB76B', '#FF0000', '#DAA520', '#800000', '#9370DB', '#F08080', '#FAF0E6', '#FF6347', '#FF4500', '#FFFF00', '#808080', '#00CED1', '#FFC0CB', '#FF00FF', '#F0FFFF', '#A9A9A9', '#F0E68C', '#1E90FF', '#FFDAB9', '#228B22', '#F0FFF0', '#66CDAA', '#ADD8E6', '#DA70D6', '#A0522D', '#FFE4B5', '#48D1CC', '#D2B48C', '#FFEBCD', '#8B008B', '#3CB371', '#87CEEB', '#6A5ACD', '#FFDEAD', '#FF69B4', '#BC8F8F', '#D3D3D3', '#00FF00', '#FAFAD2', '#AFEEEE', '#40E0D0', '#FFF8DC', '#20B2AA', '#00FFFF', '#FA8072', '#F0F8FF'];\n  return Object.values($themeColors).concat(colors);\n}\nexport function extractAccountNumberAndSequence(ret) {\n  let {\n    account\n  } = ret;\n\n  if (account && account.base_vesting_account) {\n    // vesting account\n    account = account.base_vesting_account?.base_account;\n  } else if (account && account.base_account) {\n    // evmos based account\n    account = account.base_account;\n  }\n\n  const accountNumber = account.account_number;\n  const sequence = account?.sequence || 0;\n  return {\n    accountNumber,\n    sequence\n  };\n}\nexport function getUserCurrencySign() {\n  let s = '';\n\n  switch (getUserCurrency()) {\n    case 'cny':\n    case 'jpy':\n      s = '¥';\n      break;\n\n    case 'krw':\n      s = '₩';\n      break;\n\n    case 'eur':\n      s = '€';\n      break;\n\n    default:\n      s = '$';\n  }\n\n  return s;\n}\nexport function consensusPubkeyToHexAddress(consensusPubkey) {\n  let raw = null;\n\n  if (typeof consensusPubkey === 'object') {\n    if (consensusPubkey['@type'] === '/cosmos.crypto.ed25519.PubKey') {\n      // raw = toBase64(fromHex(toHex(sha256(fromBase64(consensusPubkey.key))).slice(0, 40)))\n      raw = toHex(sha256(fromBase64(consensusPubkey.key))).slice(0, 40).toUpperCase();\n      return raw;\n    } // /cosmos.crypto.secp256k1.PubKey\n\n\n    if (consensusPubkey['@type'] === '/cosmos.crypto.secp256k1.PubKey') {\n      raw = new RIPEMD160().update(Buffer.from(sha256(fromBase64(consensusPubkey.key)))).digest('hex');\n      return raw;\n    }\n\n    if (consensusPubkey.type === 'tendermint/PubKeySecp256k1') {\n      raw = new RIPEMD160().update(Buffer.from(sha256(fromBase64(consensusPubkey.value)))).digest('hex').toUpperCase();\n      return raw;\n    }\n\n    raw = sha256(fromBase64(consensusPubkey.value));\n  } else {\n    raw = sha256(fromHex(toHex(fromBech32(consensusPubkey).data).toUpperCase().replace('1624DE6420', '')));\n  }\n\n  const address = toHex(raw).slice(0, 40).toUpperCase();\n  return address;\n}\n\nfunction toSignAddress(addr) {\n  const {\n    data\n  } = addressDecode(addr);\n  return addressEnCode('cosmos', data);\n}\n\nfunction getHdPath(address) {\n  let hdPath = \"m/44'/118/0'/0/0\";\n  Object.values(getLocalAccounts()).forEach(item => {\n    const curr = item.address.find(i => i.addr === address);\n\n    if (curr && curr.hdpath) {\n      hdPath = curr.hdpath;\n    }\n  }); //  m/0'/1/2'/2/1000000000\n\n  return stringToPath(hdPath);\n}\n\nfunction isEvmosBasedChain(chainId) {\n  const re = /[_]{1}[\\d]{4}[\\\\-]{1}[\\d]+$/g;\n  return re.test(chainId);\n}\n\nexport async function sign(device, chainId, signerAddress, messages, fee, memo, signerData) {\n  const hdpath = getHdPath(signerAddress);\n  let client;\n\n  if (device.startsWith('ledger')) {\n    client = await getSigningClient(device, hdpath);\n  } else {\n    if (!window.getOfflineSigner || !window.keplr) {\n      throw new Error('Please install keplr extension');\n    }\n\n    await window.keplr.enable(chainId);\n\n    if (isEvmosBasedChain(chainId)) {\n      const signer = window.getOfflineSigner(chainId);\n      client = await SigningKeplerEthermintClient.offline(signer);\n    } else {\n      const signer = window.getOfflineSignerOnlyAmino(chainId);\n      client = await SigningStargateClient.offline(signer);\n    }\n  }\n\n  const coinType = Number(hdpath[1]);\n  const addr = device.startsWith('ledger') && coinType !== 60 ? toSignAddress(signerAddress) : signerAddress;\n  return client.sign(addr, messages, fee, memo, signerData);\n} // import address from ledger\n\nasync function getLedgerAppName(coinType, device, hdpath) {\n  let ledgerAppName = 'Cosmos';\n\n  switch (coinType) {\n    case 60:\n      return EthereumLedgerSigner.create(device, hdpath);\n    // 'Ethereum'\n\n    case 529:\n      ledgerAppName = 'Secret'; // 'Secret'\n\n      break;\n\n    case 852:\n      ledgerAppName = 'Desmos'; // 'Desmos'\n\n      break;\n\n    case 330:\n      ledgerAppName = 'Terra'; // 'Terra'\n\n      break;\n\n    case 118:\n    default:\n  }\n\n  const transport = await (device === 'ledgerBle' ? TransportWebBLE.create() : TransportWebUSB.create());\n  return new LedgerSigner(transport, {\n    hdPaths: [hdpath],\n    ledgerAppName\n  });\n}\n\nexport async function getLedgerAddress(transport = 'blu', hdPath = \"m/44'/118/0'/0/0\") {\n  const protocol = transport === 'usb' ? await TransportWebUSB.create() : await TransportWebBLE.create(); // extract Cointype from from HDPath\n\n  const coinType = Number(stringToPath(hdPath)[1]);\n  const signer = await getLedgerAppName(coinType, protocol, stringToPath(hdPath));\n  return signer.getAccounts();\n} /// end import address from ledger\n\nexport function toDuration(value) {\n  return dayjs.duration(value).humanize();\n} // unit(y M d h m s ms)\n\nexport function timeIn(time, amount, unit = 's') {\n  const input = dayjs(time).add(amount, unit);\n  return dayjs().unix() > input.unix();\n}\nexport function toDay(time, format = 'long') {\n  if (format === 'long') {\n    return dayjs(time).format('YYYY-MM-DD HH:mm');\n  }\n\n  if (format === 'date') {\n    return dayjs(time).format('YYYY-MM-DD');\n  }\n\n  if (format === 'time') {\n    return dayjs(time).format('HH:mm:ss');\n  }\n\n  if (format === 'from') {\n    return dayjs(time).fromNow();\n  }\n\n  if (format === 'to') {\n    return dayjs(time).toNow();\n  }\n\n  return dayjs(time).format('YYYY-MM-DD HH:mm:ss');\n}\nexport function percent(num) {\n  return parseFloat((num * 100).toFixed(2));\n}\nexport function abbr(string, length = 6, suffix = '...') {\n  if (string && string.length > length) {\n    return `${string.substring(0, length)}${suffix}`;\n  }\n\n  return string;\n}\nexport function abbrRight(string, length = 6, suffix = '...') {\n  if (string && string.length > length) {\n    return `${string.substring(string.length - length)}${suffix}`;\n  }\n\n  return string;\n}\nexport function abbrMessage(msg) {\n  if (Array.isArray(msg)) {\n    const sum = msg.map(x => abbrMessage(x)).reduce((s, c) => {\n      const sh = s;\n\n      if (sh[c]) {\n        sh[c] += 1;\n      } else {\n        sh[c] = 1;\n      }\n\n      return sh;\n    }, {});\n    const output = [];\n    Object.keys(sum).forEach(k => {\n      output.push(sum[k] > 1 ? `${k}×${sum[k]}` : k);\n    });\n    return output.join(', ');\n  }\n\n  if (msg['@type']) {\n    return msg['@type'].substring(msg['@type'].lastIndexOf('.') + 1).replace('Msg', '');\n  }\n\n  if (msg.typeUrl) {\n    return msg.typeUrl.substring(msg.typeUrl.lastIndexOf('.') + 1).replace('Msg', '');\n  }\n\n  return msg.type.substring(msg.type.lastIndexOf('/') + 1).replace('Msg', '');\n}\nexport function abbrAddress(address, length = 10) {\n  return address.substring(0, length).concat('...', address.substring(address.length - length));\n}\nexport function isStringArray(value) {\n  let is = false;\n\n  if (Array.isArray(value)) {\n    is = value.findIndex(x => typeof x === 'string') > -1;\n  }\n\n  return is;\n}\nexport function isToken(value) {\n  let is = false;\n\n  if (Array.isArray(value)) {\n    is = value.findIndex(x => Object.keys(x).includes('denom')) > -1;\n  } else {\n    is = Object.keys(value).includes('denom');\n  }\n\n  return is;\n}\nexport function formatTokenDenom(tokenDenom) {\n  if (tokenDenom && tokenDenom.code === undefined) {\n    let denom = tokenDenom.denom_trace ? tokenDenom.denom_trace.base_denom : tokenDenom;\n    const chains = getLocalChains();\n    const selected = localStorage.getItem('selected_chain');\n    const selChain = chains[selected];\n    const nativeAsset = selChain.assets.find(a => a.base === denom);\n\n    if (nativeAsset) {\n      denom = nativeAsset.symbol;\n    } else {\n      const config = Object.values(chains);\n      config.forEach(x => {\n        if (x.assets) {\n          const asset = x.assets.find(a => a.base === denom);\n          if (asset) denom = asset.symbol;\n        }\n      });\n    }\n\n    return denom.length > 10 ? `${denom.substring(0, 7).toUpperCase()}..${denom.substring(denom.length - 3)}` : denom.toUpperCase();\n  }\n\n  return '';\n}\nexport function getUnitAmount(amount, tokenDenom) {\n  const denom = tokenDenom.denom_trace ? tokenDenom.denom_trace.base_denom : tokenDenom;\n  let exp = String(denom).startsWith('gravity') ? 18 : 6;\n  const config = Object.values(getLocalChains());\n  config.forEach(x => {\n    if (x.assets) {\n      const asset = x.assets.find(a => a.base === denom);\n      if (asset) exp = asset.exponent;\n    }\n  }); // eslint-disable-next-line no-undef\n\n  return String(BigInt(Number(amount) * 10 ** exp));\n}\nexport function numberWithCommas(x) {\n  const parts = x.toString().split('.');\n  parts[0] = parts[0].replace(/\\B(?=(\\d{3})+(?!\\d))/g, ',');\n  return parts.join('.');\n}\nexport function formatTokenAmount(tokenAmount, decimals = 2, tokenDenom = 'uatom', format = true) {\n  const denom = tokenDenom.denom_trace ? tokenDenom.denom_trace.base_denom : tokenDenom;\n  let amount = 0;\n  let exp = String(denom).startsWith('gravity') ? 18 : 6;\n  const config = Object.values(getLocalChains());\n  config.forEach(x => {\n    if (x.assets) {\n      const asset = x.assets.find(a => a.base === denom);\n      if (asset) exp = asset.exponent;\n    }\n  });\n  amount = Number(Number(tokenAmount)) / 10 ** exp;\n\n  if (amount > 10) {\n    if (format) {\n      return numberWithCommas(parseFloat(amount.toFixed(decimals)));\n    }\n\n    return parseFloat(amount.toFixed(decimals));\n  }\n\n  return parseFloat(amount.toFixed(exp));\n}\nexport function isTestnet() {\n  return window.location.hostname.startsWith('testnet') || window.location.search.indexOf('testnet') > -1;\n}\nexport function formatToken(token, IBCDenom = {}, decimals = 2, withDenom = true) {\n  if (token) {\n    const denom = IBCDenom[token.denom] || token.denom;\n\n    if (withDenom) {\n      return `${formatTokenAmount(token.amount, decimals, denom)} ${formatTokenDenom(denom)}`;\n    }\n\n    return formatTokenAmount(token.amount, decimals, denom);\n  }\n\n  return token;\n}\nconst COUNT_ABBRS = ['', 'K', 'M', 'B', 't', 'q', 's', 'S', 'o', 'n', 'd', 'U', 'D', 'T', 'Qt', 'Qd', 'Sd', 'St'];\nexport function formatNumber(count, withAbbr = false, decimals = 2) {\n  const i = count === 0 ? count : Math.floor(Math.log(count) / Math.log(1000));\n  let result = parseFloat((count / 1000 ** i).toFixed(decimals));\n\n  if (withAbbr && COUNT_ABBRS[i]) {\n    result += `${COUNT_ABBRS[i]}`;\n  }\n\n  return result;\n}\nexport function tokenFormatter(tokens, denoms = {}, decimal = 2) {\n  if (Array.isArray(tokens)) {\n    return tokens.map(t => formatToken(t, denoms, decimal)).join(', ');\n  }\n\n  return formatToken(tokens, denoms, 2);\n}\nexport function getCachedValidators(chainName) {\n  const locals = localStorage.getItem(`validators-${chainName}`);\n  return locals;\n}\nexport function isHexAddress(v) {\n  // const re = /^[A-Z\\d]{40}$/\n  // return re.test(v)\n  return v.length === 28;\n}\nexport function getStakingValidatorByHex(chainName, textBase64) {\n  const locals = localStorage.getItem(`validators-${chainName}`);\n\n  if (locals) {\n    const val = JSON.parse(locals).find(x => toBase64(fromHex(consensusPubkeyToHexAddress(x.consensus_pubkey))) === textBase64);\n\n    if (val) {\n      return val.description.moniker;\n    }\n  }\n\n  return abbr(textBase64);\n}\nexport function getStakingValidatorByAccount(chainName, addr) {\n  const locals = localStorage.getItem(`validators-${chainName}`);\n\n  if (locals) {\n    const val = JSON.parse(locals).find(x => operatorAddressToAccount(x.operator_address) === addr);\n\n    if (val) {\n      return val.description.moniker;\n    }\n  }\n\n  return addr;\n}\nexport function getStakingValidatorOperator(chainName, addr, length = -1) {\n  const locals = localStorage.getItem(`validators-${chainName}`);\n\n  if (locals) {\n    const val = JSON.parse(locals).find(x => x.operator_address === addr);\n\n    if (val) {\n      return val.description.moniker;\n    }\n  }\n\n  if (length > 0) {\n    return addr.substring(addr.length - length);\n  }\n\n  return addr;\n}\nexport * from 'compare-versions';\nexport * from './data';\nexport class Data {}","map":null,"metadata":{},"sourceType":"module"}